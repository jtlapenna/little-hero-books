{
  "name": "5. Error Recovery",
  "nodes": [
    {
      "id": "1",
      "name": "Cron Trigger (Every 15 minutes)",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [240, 300],
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 15
            }
          ]
        }
      }
    },
    {
      "id": "2",
      "name": "Find Failed Orders",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [460, 300],
      "parameters": {
        "functionCode": "// Find orders that have failed or are stuck in processing\n// In production, this would query the database for failed orders\n// For now, we'll simulate finding failed orders\n\nconst failedOrders = [\n  // Example failed orders - in production these would come from database\n  {\n    amazonOrderId: 'ORDER-001',\n    status: 'ai_generation_failed',\n    errorType: 'openai_api_error',\n    errorMessage: 'OpenAI API rate limit exceeded',\n    failedAt: new Date(Date.now() - 30 * 60 * 1000).toISOString(), // 30 minutes ago\n    retryCount: 0,\n    maxRetries: 3,\n    nextRetryAt: new Date(Date.now() + 5 * 60 * 1000).toISOString() // 5 minutes from now\n  },\n  {\n    amazonOrderId: 'ORDER-002',\n    status: 'book_assembly_failed',\n    errorType: 'pdf_generation_error',\n    errorMessage: 'PDF generation service unavailable',\n    failedAt: new Date(Date.now() - 45 * 60 * 1000).toISOString(), // 45 minutes ago\n    retryCount: 1,\n    maxRetries: 3,\n    nextRetryAt: new Date(Date.now() + 10 * 60 * 1000).toISOString() // 10 minutes from now\n  },\n  {\n    amazonOrderId: 'ORDER-003',\n    status: 'print_submission_failed',\n    errorType: 'lulu_api_error',\n    errorMessage: 'Lulu API authentication failed',\n    failedAt: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // 1 hour ago\n    retryCount: 2,\n    maxRetries: 3,\n    nextRetryAt: new Date(Date.now() + 15 * 60 * 1000).toISOString() // 15 minutes from now\n  }\n];\n\n// Filter orders that are ready for retry\nconst now = new Date();\nconst ordersReadyForRetry = failedOrders.filter(order => {\n  return new Date(order.nextRetryAt) <= now && order.retryCount < order.maxRetries;\n});\n\nconsole.log(`Found ${ordersReadyForRetry.length} orders ready for retry`);\nreturn ordersReadyForRetry.map(order => ({ json: order }));"
      }
    },
    {
      "id": "3",
      "name": "Analyze Error Type",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [680, 300],
      "parameters": {
        "functionCode": "// Analyze error type and determine recovery strategy\nconst orderData = $input.first().json;\n\nconst errorAnalysis = {\n  errorType: orderData.errorType,\n  errorMessage: orderData.errorMessage,\n  retryCount: orderData.retryCount,\n  maxRetries: orderData.maxRetries,\n  recoveryStrategy: getRecoveryStrategy(orderData.errorType),\n  canRetry: orderData.retryCount < orderData.maxRetries,\n  requiresManualIntervention: orderData.retryCount >= orderData.maxRetries,\n  estimatedRetryDelay: getRetryDelay(orderData.errorType, orderData.retryCount)\n};\n\nfunction getRecoveryStrategy(errorType) {\n  const strategies = {\n    'openai_api_error': 'retry_with_backoff',\n    'pdf_generation_error': 'retry_with_fallback',\n    'lulu_api_error': 'retry_with_auth_refresh',\n    'network_error': 'retry_immediately',\n    'validation_error': 'fix_data_and_retry',\n    'unknown_error': 'escalate_to_manual'\n  };\n  return strategies[errorType] || 'escalate_to_manual';\n}\n\nfunction getRetryDelay(errorType, retryCount) {\n  const baseDelays = {\n    'openai_api_error': 300000, // 5 minutes\n    'pdf_generation_error': 600000, // 10 minutes\n    'lulu_api_error': 900000, // 15 minutes\n    'network_error': 60000, // 1 minute\n    'validation_error': 300000, // 5 minutes\n    'unknown_error': 1800000 // 30 minutes\n  };\n  \n  const baseDelay = baseDelays[errorType] || 300000;\n  return baseDelay * Math.pow(2, retryCount); // Exponential backoff\n}\n\nconst analyzedOrder = {\n  ...orderData,\n  errorAnalysis: errorAnalysis,\n  analyzedAt: new Date().toISOString()\n};\n\nconsole.log(`Error analysis for order ${orderData.amazonOrderId}: ${errorAnalysis.recoveryStrategy}`);\nreturn [{ json: analyzedOrder }];"
      }
    },
    {
      "id": "4",
      "name": "Check Recovery Strategy",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [900, 300],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{ $json.errorAnalysis.recoveryStrategy }}",
              "rightValue": "retry_with_backoff",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "condition2",
              "leftValue": "={{ $json.errorAnalysis.recoveryStrategy }}",
              "rightValue": "retry_with_fallback",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "condition3",
              "leftValue": "={{ $json.errorAnalysis.recoveryStrategy }}",
              "rightValue": "retry_with_auth_refresh",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "condition4",
              "leftValue": "={{ $json.errorAnalysis.recoveryStrategy }}",
              "rightValue": "retry_immediately",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        }
      }
    },
    {
      "id": "5",
      "name": "Retry AI Generation",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 200],
      "parameters": {
        "functionCode": "// Retry AI generation for failed orders\nconst orderData = $input.first().json;\n\n// Increment retry count\nconst retryCount = orderData.retryCount + 1;\n\n// Apply retry delay if needed\nconst retryDelay = orderData.errorAnalysis.estimatedRetryDelay;\nconst nextRetryAt = new Date(Date.now() + retryDelay).toISOString();\n\nconst retryOrder = {\n  ...orderData,\n  retryCount: retryCount,\n  nextRetryAt: nextRetryAt,\n  status: 'retrying_ai_generation',\n  retryStartedAt: new Date().toISOString(),\n  retryStrategy: 'ai_generation_retry'\n};\n\nconsole.log(`Retrying AI generation for order ${orderData.amazonOrderId} (attempt ${retryCount})`);\nreturn [{ json: retryOrder }];"
      }
    },
    {
      "id": "6",
      "name": "Retry Book Assembly",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 300],
      "parameters": {
        "functionCode": "// Retry book assembly for failed orders\nconst orderData = $input.first().json;\n\n// Increment retry count\nconst retryCount = orderData.retryCount + 1;\n\n// Apply retry delay if needed\nconst retryDelay = orderData.errorAnalysis.estimatedRetryDelay;\nconst nextRetryAt = new Date(Date.now() + retryDelay).toISOString();\n\nconst retryOrder = {\n  ...orderData,\n  retryCount: retryCount,\n  nextRetryAt: nextRetryAt,\n  status: 'retrying_book_assembly',\n  retryStartedAt: new Date().toISOString(),\n  retryStrategy: 'book_assembly_retry'\n};\n\nconsole.log(`Retrying book assembly for order ${orderData.amazonOrderId} (attempt ${retryCount})`);\nreturn [{ json: retryOrder }];"
      }
    },
    {
      "id": "7",
      "name": "Retry Print Submission",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 400],
      "parameters": {
        "functionCode": "// Retry print submission for failed orders\nconst orderData = $input.first().json;\n\n// Increment retry count\nconst retryCount = orderData.retryCount + 1;\n\n// Apply retry delay if needed\nconst retryDelay = orderData.errorAnalysis.estimatedRetryDelay;\nconst nextRetryAt = new Date(Date.now() + retryDelay).toISOString();\n\nconst retryOrder = {\n  ...orderData,\n  retryCount: retryCount,\n  nextRetryAt: nextRetryAt,\n  status: 'retrying_print_submission',\n  retryStartedAt: new Date().toISOString(),\n  retryStrategy: 'print_submission_retry'\n};\n\nconsole.log(`Retrying print submission for order ${orderData.amazonOrderId} (attempt ${retryCount})`);\nreturn [{ json: retryOrder }];"
      }
    },
    {
      "id": "8",
      "name": "Retry Immediately",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1120, 500],
      "parameters": {
        "functionCode": "// Retry immediately for transient errors\nconst orderData = $input.first().json;\n\n// Increment retry count\nconst retryCount = orderData.retryCount + 1;\n\nconst retryOrder = {\n  ...orderData,\n  retryCount: retryCount,\n  nextRetryAt: new Date().toISOString(), // Immediate retry\n  status: 'retrying_immediately',\n  retryStartedAt: new Date().toISOString(),\n  retryStrategy: 'immediate_retry'\n};\n\nconsole.log(`Retrying immediately for order ${orderData.amazonOrderId} (attempt ${retryCount})`);\nreturn [{ json: retryOrder }];"
      }
    },
    {
      "id": "9",
      "name": "Escalate to Manual Review",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1340, 300],
      "parameters": {
        "functionCode": "// Escalate failed orders to manual review\nconst orderData = $input.first().json;\n\nconst escalatedOrder = {\n  ...orderData,\n  status: 'escalated_to_manual',\n  escalatedAt: new Date().toISOString(),\n  escalationReason: 'Max retries exceeded or unknown error',\n  requiresManualIntervention: true,\n  priority: getEscalationPriority(orderData)\n};\n\nfunction getEscalationPriority(order) {\n  // Higher priority for older orders\n  const hoursSinceFailure = (Date.now() - new Date(order.failedAt)) / (1000 * 60 * 60);\n  if (hoursSinceFailure > 24) return 'high';\n  if (hoursSinceFailure > 12) return 'medium';\n  return 'low';\n}\n\nconsole.log(`Escalated order ${orderData.amazonOrderId} to manual review`);\nreturn [{ json: escalatedOrder }];"
      }
    },
    {
      "id": "10",
      "name": "Send Error Notifications",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1560, 300],
      "parameters": {
        "method": "POST",
        "url": "https://api.sendgrid.com/v3/mail/send",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "sendgridApi",
        "options": {
          "headers": {
            "parameters": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        },
        "bodyParameters": {
          "parameters": [
            {
              "name": "personalizations",
              "value": "=[{\n  \"to\": [{\"email\": \"{{ $json.customerEmail || 'admin@littleherobooks.com' }}\"}],\n  \"subject\": \"Order Update - {{ $json.amazonOrderId }}\"\n}]"
            },
            {
              "name": "from",
              "value": "={\n  \"email\": \"orders@littleherobooks.com\",\n  \"name\": \"Little Hero Books\"\n}"
            },
            {
              "name": "content",
              "value": "=[{\n  \"type\": \"text/html\",\n  \"value\": \"<h2>Order Update</h2><p>We're experiencing a delay with your order {{ $json.amazonOrderId }}. Our team is working to resolve this issue and will update you soon.</p><p>We apologize for any inconvenience.</p>\"\n}]"
            }
          ]
        }
      }
    },
    {
      "id": "11",
      "name": "Update Order Status",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1780, 300],
      "parameters": {
        "functionCode": "// Update order status based on recovery action\nconst orderData = $input.first().json;\n\nconst updatedOrder = {\n  ...orderData,\n  lastRecoveryAction: new Date().toISOString(),\n  recoveryStatus: 'action_taken'\n};\n\nconsole.log(`Updated order status for ${orderData.amazonOrderId}: ${orderData.status}`);\nreturn [{ json: updatedOrder }];"
      }
    },
    {
      "id": "12",
      "name": "Log Recovery Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2000, 300],
      "parameters": {
        "functionCode": "// Log recovery results for monitoring\nconst orderData = $input.first().json;\n\nconst logEntry = {\n  timestamp: new Date().toISOString(),\n  workflow: '5-error-recovery',\n  orderId: orderData.amazonOrderId,\n  status: orderData.status,\n  errorType: orderData.errorType,\n  errorMessage: orderData.errorMessage,\n  retryCount: orderData.retryCount,\n  maxRetries: orderData.maxRetries,\n  recoveryStrategy: orderData.errorAnalysis?.recoveryStrategy || 'unknown',\n  retryStrategy: orderData.retryStrategy || 'none',\n  nextRetryAt: orderData.nextRetryAt,\n  escalated: orderData.requiresManualIntervention || false,\n  priority: orderData.priority || 'normal'\n};\n\n// In production, this would write to a proper logging system\nconsole.log('Error Recovery Results:', JSON.stringify(logEntry, null, 2));\n\nreturn [{ json: logEntry }];"
      }
    }
  ],
  "connections": {
    "Cron Trigger (Every 15 minutes)": {
      "main": [
        [
          {
            "node": "Find Failed Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Failed Orders": {
      "main": [
        [
          {
            "node": "Analyze Error Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Error Type": {
      "main": [
        [
          {
            "node": "Check Recovery Strategy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Recovery Strategy": {
      "main": [
        [
          {
            "node": "Retry AI Generation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Retry Book Assembly",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Retry Print Submission",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Retry Immediately",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Escalate to Manual Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retry AI Generation": {
      "main": [
        [
          {
            "node": "Update Order Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retry Book Assembly": {
      "main": [
        [
          {
            "node": "Update Order Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retry Print Submission": {
      "main": [
        [
          {
            "node": "Update Order Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retry Immediately": {
      "main": [
        [
          {
            "node": "Update Order Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate to Manual Review": {
      "main": [
        [
          {
            "node": "Send Error Notifications",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Error Notifications": {
      "main": [
        [
          {
            "node": "Update Order Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Order Status": {
      "main": [
        [
          {
            "node": "Log Recovery Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T10:00:00.000Z",
  "versionId": "1"
}
