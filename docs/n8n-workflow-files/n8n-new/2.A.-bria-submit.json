{
  "name": "LHB - 2.A.- Character Creation - WORKING NEW",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Generate a mock order for testing the AI character generation workflow\n// This simulates an order coming from the order intake workflow\n\nconst mockOrder = {\n  amazonOrderId: 'TEST-ORDER-002',\n  status: 'queued_for_processing',\n  orderDate: new Date().toISOString(),\n  customerEmail: 'test@example.com',\n  characterSpecs: {\n    childName: 'Alex',\n    skinTone: 'medium',\n    hairColor: 'black',\n    hairStyle: 'medium/ponytail',\n    age: 4,\n    pronouns: 'he/him',\n    favoriteColor: 'yellow',\n    animalGuide: 'dog',\n    clothingStyle: 't-shirt and shorts'\n  },\n  bookSpecs: {\n    title: 'Alex and the Adventure Compass',\n    totalPages: 16,\n    format: '8.5x8.5_softcover',\n    bookType: 'animal-guide' // or 'mvp-simple' for different book types\n  },\n  orderDetails: {\n    quantity: 1,\n    shippingAddress: {\n      name: 'Test Customer',\n      address: '123 Test Street',\n      city: 'Test City',\n      state: 'CA',\n      zip: '90210'\n    }\n  }\n};\n\nconsole.log('Generated mock order for testing:', mockOrder);\nreturn [{ json: mockOrder }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8160,
        7392
      ],
      "id": "962616d0-c064-4bd7-add5-115a192ed8d2",
      "name": "Generate Mock Order"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -3856,
        7168
      ],
      "id": "3767be79-18fc-4019-a81b-32348798faed",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "functionCode": "// Get next order from processing queue and extract custom elements\n// In production, this would query a database queue\n// For now, we'll simulate getting an order from the previous workflow\n\nconst inputData = $input.first();\nif (!inputData || !inputData.json) {\n  console.log('No input data received');\n  return [];\n}\n\nconst orderData = inputData.json;\n\n// Check if order is ready for AI generation\nif (orderData.status !== 'queued_for_processing') {\n  console.log(`Order ${orderData.amazonOrderId} not ready for processing. Status: ${orderData.status}`);\n  return [];\n}\n\n// Extract and validate custom elements from characterSpecs\nconst characterSpecs = orderData.characterSpecs || {};\nconst customElements = {\n  childName: characterSpecs.childName || 'Adventure Hero',\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Update order status to processing with custom elements\nconst processingOrder = {\n  ...orderData,\n  characterSpecs: customElements,\n  status: 'ai_generation_in_progress',\n  aiGenerationStartedAt: new Date().toISOString(),\n  posesGenerated: 0,\n  totalPosesRequired: 12,\n  generationProgress: 0\n};\n\nconsole.log(`Starting AI generation for order: ${orderData.amazonOrderId}`);\nconsole.log(`Custom elements:`, customElements);\nreturn [{ json: processingOrder }];"
      },
      "id": "c5123d73-331a-4a44-ae9c-5821e56d7ea1",
      "name": "Get Next Order from Queue",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -7936,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate character hash for reuse detection\nconst orderData = $input.first().json;\nconst characterSpecs = orderData.characterSpecs || {};\n\n// Create a normalized character specification object for hashing\nconst characterHashSpec = {\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Generate a deterministic hash from the character specifications\nconst crypto = require('crypto');\nconst hashString = JSON.stringify(characterHashSpec, Object.keys(characterHashSpec).sort());\nconst characterHash = crypto.createHash('sha256').update(hashString).digest('hex').substring(0, 16);\n\n// Add character hash and normalized specs to order data\nconst orderWithHash = {\n  ...orderData,\n  characterHash: characterHash,\n  characterHashSpec: characterHashSpec,\n  characterPath: `characters/${characterHash}`,\n  templatePath: 'templates'\n};\n\nconsole.log(`Generated character hash: ${characterHash}`);\nconsole.log(`Character specs:`, characterHashSpec);\n\nreturn [{ json: orderWithHash }];"
      },
      "id": "cc62a80b-ba11-49e9-9bd6-8530ef330074",
      "name": "Generate Character Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7712,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Restore metadata after S3 upload\nconst uploadResult = $input.first();\nconst originalData = $('Process Gemini API response and extract generated image').first();\n\nreturn [{\n  json: {\n    ...originalData.json,\n    s3UploadResult: uploadResult.json,\n    baseCharacterUploaded: true,\n    baseCharacterUploadedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "bf59ff61-3d27-4e8a-980d-7dfdbbbc9017",
      "name": "Restore Metadata After Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6368,
        7392
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize pose generation loop\nconst orderData = $input.first().json;\n\nconst existingPoses = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n\nconsole.log(`Using existing poses: ${existingPoses.join(', ')}`);\n\nconst posesToGenerate = existingPoses.map(poseNumber => ({\n  ...orderData,\n  currentPoseNumber: poseNumber,\n  poseStatus: 'pending',\n  poseGenerationAttempts: 0,\n  maxPoseAttempts: 3\n}));\n\nconsole.log(`Initialized pose generation for ${posesToGenerate.length} poses`);\nreturn posesToGenerate.map(pose => ({ json: pose }));"
      },
      "id": "e2db4ee1-be95-4638-8982-ed983f9b94f0",
      "name": "Initialize Pose Generation Loop",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -5920,
        7472
      ]
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.characterPath }}/base-character.png"
      },
      "id": "6aa4cd62-fe9c-4ebc-98e1-dce81f566490",
      "name": "Load Custom Character from R2",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -6144,
        7392
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "=book-mvp-simple-adventure/characters/poses/pose{{ $json.currentPoseNumber.toString().padStart(2, '0') }}.png"
      },
      "id": "5e40986d-cf8b-4b83-bc7d-4b2affb83db1",
      "name": "Load Pose Reference",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -5696,
        7472
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {},
      "id": "eccc7e7f-ca1c-4d77-a4ea-a29a51c3a33e",
      "name": "Merge Character with Poses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -5472,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Reorganize merged data: duplicate character across all pose items\nconst items = $input.all();\nconst loopItems = $('Initialize Pose Generation Loop').all();\nconst characterLoadItem = $('Load Custom Character from R2').first();\n\nif (items.length !== 13) {\n  throw new Error(`Expected 13 items (1 character + 12 poses), got ${items.length}`);\n}\n\nconst characterItem = items[0];\nconst characterBuffer = await this.helpers.getBinaryDataBuffer(0, 'data');\nconst characterBase64 = characterBuffer.toString('base64');\n\nif (!characterBase64 || characterBase64.length < 100) {\n  throw new Error('Invalid character binary');\n}\n\nconst characterPath = characterLoadItem.json.characterPath;\nconst characterHash = characterLoadItem.json.characterHash;\n\nconst results = [];\nfor (let i = 1; i < items.length; i++) {\n  const poseItem = items[i];\n  const loopItem = loopItems[i - 1];\n  \n  const poseBuffer = await this.helpers.getBinaryDataBuffer(i, 'data');\n  const poseBase64 = poseBuffer.toString('base64');\n  \n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Invalid pose binary for item ${i}`);\n  }\n  \n  const currentPoseNumber = loopItem.json.currentPoseNumber;\n  \n  results.push({\n    json: {\n      ...loopItem.json,\n      characterBase64: characterBase64,\n      poseBase64: poseBase64,\n      characterPath: characterPath,\n      characterHash: characterHash,\n      poseNumber: currentPoseNumber,\n      currentPoseNumber: currentPoseNumber\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "36bc39c0-06d7-4f78-8d80-7f0a375ec04f",
      "name": "Reorganize Merged Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5248,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Gemini API request with character and pose images\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  const characterBase64 = item.json.characterBase64;\n  const poseBase64 = item.json.poseBase64;\n  const currentPoseNumber = item.json.currentPoseNumber;\n  const characterSpecs = item.json.characterSpecs;\n  \n  if (!characterBase64 || characterBase64.length < 100) {\n    throw new Error(`Character base64 data missing or invalid for pose ${currentPoseNumber}`);\n  }\n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Pose base64 data missing or invalid for pose ${currentPoseNumber}`);\n  }\n  if (!characterSpecs) {\n    throw new Error(`Character specifications missing for pose ${currentPoseNumber}`);\n  }\n\n  const systemText = `You are a precise illustration tool. CRITICAL: You must preserve the EXACT appearance from IMAGE A. IMAGE B is ONLY for body position - ignore ALL visual traits from IMAGE B. CONFLICT RULE: Always follow IMAGE A for appearance.`;\n\n  const promptText = `ULTRA-CRITICAL INSTRUCTION:\nYou must generate EXACTLY ONE image that combines:\n- The EXACT character appearance from IMAGE A (skin tone, hair color, hair length, hair style, clothing, facial features)\n- The EXACT body pose and position from IMAGE B (stance, limb positions, body angle)\n\nMANDATORY APPEARANCE TRAITS (from IMAGE A - DO NOT CHANGE):\n- Hair: ${characterSpecs.hairColor} ${characterSpecs.hairStyle} hair\n- Skin: ${characterSpecs.skinTone} skin tone\n- Clothing: ${characterSpecs.clothingStyle}\n- Age: ${characterSpecs.age} years old\n\nREQUIREMENTS:\n- Style: Watercolor storybook illustration\n- Background: Pure white (#FFFFFF) - NO transparency\n- Output: Character from IMAGE A in pose from IMAGE B\n- Ensure only ONE pair of legs, ONE pair of arms, and ONE head per character\n\nGenerate the image now.`;\n\n  const requestBody = {\n    systemInstruction: {\n      role: 'system',\n      parts: [{ text: systemText }]\n    },\n    contents: [{\n      role: 'user',\n      parts: [\n        { text: 'IMAGE A – CHARACTER REFERENCE (your source of truth for appearance):' },\n        { inlineData: { mimeType: \"image/png\", data: characterBase64 } },\n        { text: 'IMAGE B – POSE REFERENCE (body position ONLY, ignore character appearance):' },\n        { inlineData: { mimeType: \"image/png\", data: poseBase64 } },\n        { text: promptText }\n      ]\n    }],\n    generationConfig: {\n      imageConfig: { aspectRatio: \"1:1\" },\n      temperature: 0.3\n    }\n  };\n\n  results.push({\n    json: {\n      ...item.json,\n      requestBody: requestBody\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "172f16f6-9bf7-4713-98a1-07c9df6c7b1f",
      "name": "Prepare Gemini Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5024,
        7392
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "id": "98954803-3fe0-434e-9cb2-5e559b28aa0c",
      "name": "Generate Character in Pose",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4800,
        7392
      ],
      "credentials": {
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract generated image from Gemini response\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const currentPoseNumber = item.json.currentPoseNumber || (i + 1);\n  \n  try {\n    const responseData = item.json;\n    \n    if (!responseData.candidates || responseData.candidates.length === 0) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No candidates found in response',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    const candidate = responseData.candidates[0];\n    \n    if (candidate.finishReason && candidate.finishReason !== 'STOP') {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: `Generation not completed, finishReason: ${candidate.finishReason}`,\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No content parts found in candidate',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    const imagePart = candidate.content.parts.find(part => part.inlineData && part.inlineData.data);\n    \n    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No image data found in parts',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    const imageData = imagePart.inlineData.data;\n    \n    if (!imageData || imageData.length < 100) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: `Invalid image data`,\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    results.push({\n      json: {\n        ...item.json,\n        extractedImageData: imageData,\n        extractionSuccess: true,\n        _STATUS: 'IMAGE_FOUND'\n      }\n    });\n    \n  } catch (error) {\n    results.push({\n      json: {\n        ...item.json,\n        extractedImageData: null,\n        extractionError: error.message,\n        _STATUS: 'FAILED'\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "065ca359-a81a-41b3-9fef-90b9590b3c70",
      "name": "Extract Generated Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4576,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Diagnostic: Check what fields we actually have\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  const diagnostic = {\n    itemIndex: i,\n    allKeys: Object.keys(item.json),\n    hasCharacterPath: !!item.json.characterPath,\n    hasCharacterHash: !!item.json.characterHash,\n    hasCurrentPoseNumber: !!item.json.currentPoseNumber,\n    hasCharacterSpecs: !!item.json.characterSpecs,\n    characterPath: item.json.characterPath,\n    characterHash: item.json.characterHash,\n    currentPoseNumber: item.json.currentPoseNumber\n  };\n  \n  results.push({\n    json: {\n      ...item.json,\n      _DIAGNOSTIC: diagnostic\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "97789c8b-f654-4e6a-abaa-827a0c1ecce1",
      "name": "DIAGNOSTIC: Check Fields",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4352,
        7392
      ],
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json._STATUS }}",
              "value2": "IMAGE_FOUND"
            }
          ]
        }
      },
      "id": "5e18c86a-0bb1-4235-afc5-a6c0373ca89f",
      "name": "Filter: Only Items With Images",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -4128,
        7392
      ]
    },
    {
      "parameters": {
        "url": "https://pub-92cec53654f84771956bc84dfea65baa.r2.dev/book-mvp-simple-adventure/characters/base-character.png",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7488,
        7392
      ],
      "id": "385b3e7b-16ed-4ccf-b8eb-5c95db97cd7a",
      "name": "Load Reference Image"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -7040,
        7392
      ],
      "id": "5de869c4-fbbf-43a3-ae34-2624b6f977db",
      "name": "Generate Custom Base Character",
      "credentials": {
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract first image from Gemini response and output as n8n binary\nconst input = $input.first();\nconst res = input.json;\n\nconst parts = res?.candidates?.[0]?.content?.parts ?? [];\nconst imagePart = parts.find(p => p?.inlineData?.data);\n\nif (!imagePart?.inlineData?.data) {\n  throw new Error('No inlineData image found in Gemini response');\n}\n\nconst mime = imagePart.inlineData.mimeType || 'image/png';\nconst buf = Buffer.from(imagePart.inlineData.data, 'base64');\n\nconst binary = await this.helpers.prepareBinaryData(buf, 'generated.png', mime);\n\nconst originalOrderData = $('Generate Character Hash').first().json;\n\nreturn [{\n  json: {\n    ...originalOrderData,\n    generatedImage: { mimeType: mime, size: buf.length }\n  },\n  binary: { data: binary }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6816,
        7392
      ],
      "id": "df6eed13-4262-4c38-b743-60194383d55e",
      "name": "Process Gemini API response and extract generated image"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst binaryKey = 'data';\n\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Image = buffer.toString('base64');\n\nif (!base64Image || base64Image.length < 100) {\n  throw new Error('Invalid base64 from binary buffer');\n}\n\nconst cs = item.json.characterSpecs;\nconst requestBody = {\n  contents: [{\n    parts: [\n      { text: `Use this reference image as a style guide. Recreate this exact character pose with the following changes: skin tone: ${cs.skinTone}, hair color: ${cs.hairColor}, hair style: ${cs.hairStyle}, clothing style: ${cs.clothingStyle}, favorite color: ${cs.favoriteColor}. Maintain the same watercolor storybook style, proportions, and pose. Character should be on pure white background (#FFFFFF) - NO transparency. Age-appropriate for ${cs.age} years old.` },\n      { inlineData: { mimeType: \"image/png\", data: base64Image } }\n    ]\n  }],\n  generationConfig: { imageConfig: { aspectRatio: \"1:1\" } }\n};\n\nreturn [{ json: { ...item.json, requestBody } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7264,
        7392
      ],
      "id": "99b64e50-5fe6-4049-af8c-10e3b1ba2f97",
      "name": "Prepare binary"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.characterPath }}/base-character.png",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -6592,
        7392
      ],
      "id": "f92fbf18-97f6-4e44-8cdc-89907e3693b0",
      "name": "Upload a file",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Just pass through all items - minimal validation\nconst items = $input.all();\n\nconsole.log(`Received ${items.length} items for Bria AI submission`);\n\nif (items.length > 0) {\n  console.log('Sample item fields:', Object.keys(items[0].json));\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  if (!item.json.extractedImageData) {\n    throw new Error(`Item ${i} missing extractedImageData`);\n  }\n}\n\nreturn items;"
      },
      "id": "3b7f5a69-c8be-4054-a39c-356213b15e67",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3904,
        7392
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "f8ba5a00-ed44-4004-b015-88d5103ad686",
      "name": "Loop Over Items",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -2848,
        7392
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://engine.prod.bria-api.com/v2/image/edit/remove_background",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_token",
              "value": "eb0fed5156c441148c462a74d3f92f00"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json._briaBody }}",
        "options": {}
      },
      "id": "bddbf611-049f-4df5-b780-7313eb8d6525",
      "name": "Submit to Bria AI",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        432,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Store Submission Result - Extract from Bria response + metadata (robust hash + pose + path)\n// Consolidates a Bria API response with local metadata while preferring a trusted characterHash\n// and backfilling characterPath when missing.\n\n// --- Constants (keep in sync across nodes)\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\n\n// --- Gather inputs\nconst inputs = $input.all();\n\n// --- Utilities\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// --- Identify response & meta items\nconst respItem = inputs.find(i => {\n  const j = i.json || {};\n  return j.request_id || j.status_url || j.data?.request_id || j.result?.request_id || j.links?.status;\n}) || inputs[0];\n\nconst resp = respItem?.json || {};\n\nconst metaItem = inputs.find(i => (i.json && i.json.__meta)) || inputs[0];\nconst meta = (metaItem?.json && metaItem.json.__meta) ? metaItem.json.__meta : {};\n\n// --- Pull trusted upstream hashes from other nodes (if available)\nconst metaNodeHash = $('Capture Lean Meta').first()?.json?.__meta?.characterHash;\nconst genNodeHash  = $('Generate Character Hash').first()?.json?.characterHash;\nconst upstreamHash = !isBadHash(metaNodeHash) ? metaNodeHash\n                   : (!isBadHash(genNodeHash) ? genNodeHash\n                   : null);\n\n// --- Extract Bria response fields (many shapes supported)\nconst requestId =\n  resp.request_id ?? resp.requestId ??\n  resp.data?.request_id ?? resp.result?.request_id ??\n  null;\n\nconst statusUrl =\n  resp.status_url ?? resp.statusUrl ??\n  resp.data?.status_url ?? resp.result?.status_url ??\n  resp.links?.status ?? null;\n\nconst failed = !(requestId && statusUrl);\n\n// --- Extract poseNumber from MULTIPLE sources (try everything!), clamp 1–12 just in case\nconst rawPose =\n  meta.poseNumber ??\n  metaItem?.json?.poseNumber ??\n  metaItem?.json?.currentPoseNumber ??\n  respItem?.json?.poseNumber ??\n  respItem?.json?.currentPoseNumber ??\n  1;\n\nconst poseParsed = Number.isFinite(Number(rawPose)) ? Number(rawPose) : 1;\nconst poseNumber = Math.min(12, Math.max(1, poseParsed));\n\n// --- Resolve characterHash (prefer trusted upstream → local fields; avoid placeholders)\nconst localHash =\n  meta.characterHash ??\n  metaItem?.json?.characterHash ??\n  respItem?.json?.characterHash ??\n  null;\n\nconst characterHash = !isBadHash(localHash) ? localHash\n                    : (!isBadHash(upstreamHash) ? upstreamHash\n                    : null);\n\n// --- Best-effort path/source reference, with backfill\nlet characterPath =\n  meta.characterPath ??\n  metaItem?.json?.characterPath ??\n  respItem?.json?.characterPath ??\n  metaItem?.json?.originalImageUrl ??\n  respItem?.json?.originalImageUrl ??\n  metaItem?.json?.imageUrl ??\n  respItem?.json?.imageUrl ??\n  metaItem?.json?.sourceUrl ??\n  respItem?.json?.sourceUrl ??\n  null;\n\nif (!characterPath && characterHash) {\n  characterPath = `${BASE_PREFIX}/${characterHash}/`;\n  console.log(`Backfilled characterPath=${characterPath}`);\n}\n\n// --- Logs for diagnostics\nconsole.log(\n  `Stored: pose=${poseNumber}, requestId=${requestId ? requestId.substring(0,8) : 'null'}..., failed=${failed}`\n);\nconsole.log(`[META] hasPath=${!!meta.characterPath} hasHash=${!!meta.characterHash}`);\nconsole.log(`[LOCAL] characterHash=${characterHash || 'null'} characterPath=${characterPath || 'null'}`);\n\n// --- Output\nconst out = {\n  requestId,\n  statusUrl,\n  poseNumber,\n  characterHash,          // robust (no forced placeholders)\n  characterPath,          // stable folder-style path; constructed if missing and hash present\n  failed,\n  submittedAt: new Date().toISOString(),\n};\n\nreturn [{ json: out }];\n"
      },
      "id": "a60ebbff-4c34-46d4-94d2-f7ec1a7f0b1b",
      "name": "Store Submission Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1216,
        7248
      ]
    },
    {
      "parameters": {
        "amount": 6,
        "unit": "seconds"
      },
      "id": "352aa02f-21ac-4392-9d85-e91cf145dedf",
      "name": "Wait 6 Seconds",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        1792,
        7440
      ],
      "webhookId": "rate-limit-delay",
      "notes": "Rate limiting: 10 req/min = 1 req/6 sec"
    },
    {
      "parameters": {
        "jsCode": "// === CREATE FINAL SUMMARY (robust hash propagation) ===\n\nconst incomingItems = $input.all();\nconsole.log('=== CREATE FINAL SUMMARY ===');\nconsole.log(`Received ${incomingItems.length} items from loop`);\n\n// Helper: treat placeholder hashes as empty\nconst isBadHash = (h) => !h || h === 'nohash' || h === 'unknown' || typeof h !== 'string' || h.length < 4;\n\n// Pull a trustworthy upstream hash (prefer Capture Lean Meta -> Generate Character Hash)\nconst metaHash = $('Capture Lean Meta').first()?.json?.__meta?.characterHash;\nconst genNode = $('Generate Character Hash').first()?.json || {};\nconst genHash  = genNode?.characterHash;\nconst upstreamHash = !isBadHash(metaHash) ? metaHash : (!isBadHash(genHash) ? genHash : null);\n\n// Prefer the upstream order snapshot, fall back sensibly\nconst firstItem = incomingItems[0]?.json || {};\nconst sourceOrder =\n  genNode && Object.keys(genNode).length ? genNode :\n  (firstItem || {});\n\n// Derive amazonOrderId with strong preference to Generate Character Hash node\nconst amazonOrderId =\n  genNode?.amazonOrderId ??\n  sourceOrder?.amazonOrderId ??\n  firstItem?.orderData?.amazonOrderId ??\n  firstItem?.amazonOrderId ??\n  null;\n\nconst orderData = {\n  amazonOrderId, // ← now included\n  characterHash: upstreamHash || (!isBadHash(sourceOrder.characterHash) ? sourceOrder.characterHash : null),\n  characterSpecs: sourceOrder.characterSpecs,\n  bookSpecs: sourceOrder.bookSpecs,\n  orderDetails: sourceOrder.orderDetails,\n  r2BucketName: 'little-hero-assets'\n};\n\nconsole.log('Order data snapshot:', {\n  amazonOrderId: orderData.amazonOrderId || 'null',\n  characterHash: orderData.characterHash || 'null'\n});\n\n// Build normalized submissions array with safe hash fallback\nconst submissions = incomingItems.map((item, idx) => {\n  const j = item.json || {};\n  const pose = j.poseNumber || j.currentPoseNumber || (idx + 1);\n\n  // choose item hash if it's real; otherwise fall back to the trusted upstream hash\n  const chosenHash = !isBadHash(j.characterHash) ? j.characterHash\n                    : (!isBadHash(orderData.characterHash) ? orderData.characterHash\n                    : upstreamHash);\n\n  // characterPath: prefer __meta.characterPath (public URL), then plain fields\n  const path =\n    j.__meta?.characterPath ??\n    j.characterPath ??\n    j.originalImageUrl ??\n    j.imageUrl ??\n    j.sourceUrl ??\n    null;\n\n  return {\n    requestId: j.requestId || null,\n    statusUrl: j.statusUrl || null,\n\n    // keep some context for fallbacks/diagnostics\n    extractedImageData: j.extractedImageData || null,\n\n    // pose\n    currentPoseNumber: pose,\n    poseNumber: pose,\n\n    // id & pathing\n    characterHash: chosenHash || null,\n    characterPath: path,\n\n    failed: !!j.failed,\n    submittedAt: j.submittedAt || new Date().toISOString(),\n    briaSubmissionSuccess: !!(j.requestId && j.statusUrl),\n  };\n});\n\nconst valid = submissions.filter(s => s.requestId && s.statusUrl);\nconst failed = submissions.length - valid.length;\n\nconsole.log(`Valid submissions: ${valid.length}`);\nconsole.log(`Failed submissions: ${failed}`);\nconsole.log(`Pose numbers: ${submissions.map(s => s.poseNumber).join(', ')}`);\n\nif (!orderData.amazonOrderId) {\n  console.warn('⚠️ amazonOrderId is missing. Ensure Generate Character Hash receives/forwards it.');\n}\n\nreturn [{\n  json: {\n    totalSubmissions: submissions.length,\n    successful: valid.length,\n    failed: failed,\n    submittedAt: new Date().toISOString(),\n\n    submissions,\n    orderData,           // ← CRITICAL for 2B\n    workflow2AComplete: true\n  }\n}];\n"
      },
      "id": "982fdf69-9039-44b4-a726-80fd44cebcf4",
      "name": "Create Final Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2576,
        6784
      ]
    },
    {
      "parameters": {
        "amount": 90,
        "unit": "seconds"
      },
      "id": "bf24bb2f-bda2-4744-a93f-8b52309a4ba1",
      "name": "Wait 90 Seconds",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        -2304,
        6976
      ],
      "webhookId": "wait-for-processing",
      "notes": "Give Bria AI time to process images"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://thepeakbeyond.app.n8n.cloud/webhook/bg-removal",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "6bc60532-4811-48a6-9981-4be236026521",
      "name": "Trigger Workflow B",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1856,
        6976
      ]
    },
    {
      "parameters": {
        "jsCode": "const j = $input.first().json;\ndelete j.extractedImageData;\ndelete j.poseBase64;\ndelete j.characterBase64;\ndelete j.requestBody;\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        7392
      ],
      "id": "13054fab-042b-4da9-be7f-683ad7848edc",
      "name": "Drop Heavy Fields"
    },
    {
      "parameters": {
        "jsCode": "// Capture Lean Meta — robust, preserves 1-based pose, builds stable characterPath\nconst src = ($input.first()?.json) || {};\n\n// --- Constants (keep in sync across nodes)\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\n\n// --- Utilities\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// 1) Pose number: try multiple sources, ensure 1–12 range\nconst poseNumberRaw =\n  src.poseNumber ??\n  src.currentPoseNumber ??\n  src.__meta?.poseNumber ??\n  ($itemIndex + 1); // Last resort: index + 1\n\nconst poseParsed = Number.isFinite(Number(poseNumberRaw)) ? Number(poseNumberRaw) : 1;\n// clamp to 1–12\nconst poseNumber = Math.min(12, Math.max(1, poseParsed));\nif (poseNumber !== poseParsed) {\n  console.warn(`Pose number ${poseParsed} out of range, clamped to ${poseNumber}`);\n}\n\n// 2) Character hash (prefer upstream; avoid placeholders)\nconst upstreamHash = $('Generate Character Hash').first()?.json?.characterHash;\nconst resolvedHash =\n  src.characterHash ||\n  src.characterSpecs?.hash ||\n  upstreamHash ||\n  null;\nconst characterHash = isBadHash(resolvedHash) ? null : resolvedHash;\n\n// 3) Build storage key (1-based pose numbers) only if we have a hash\nconst storageKey = characterHash\n  ? `${BASE_PREFIX}/${characterHash}/${poseNumber}.png`\n  : null;\n\n// 4) Character path: prefer existing; otherwise construct from hash\nlet characterPath =\n  src.__meta?.characterPath ||\n  src.characterPath ||\n  src.originalImageUrl ||\n  src.imageUrl ||\n  src.sourceUrl ||\n  null;\n\nif (!characterPath && characterHash) {\n  characterPath = `${BASE_PREFIX}/${characterHash}/`;\n  console.log(`Backfilled characterPath=${characterPath}`);\n}\n\n// 5) Store in __meta\nsrc.__meta = {\n  ...(src.__meta || {}),\n  poseNumber,          // 1..12\n  characterHash,       // may be null if not resolvable (no placeholders)\n  storageKey,          // null if no hash\n  characterPath        // stable folder-style path (not a full URL)\n};\n\nconsole.log(`Captured meta: pose=${poseNumber}, hash=${characterHash || 'null'}`);\n\nreturn [{ json: src }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2352,
        7232
      ],
      "id": "a292f01e-765a-45a3-b214-f6f553bd9107",
      "name": "Capture Lean Meta"
    },
    {
      "parameters": {
        "jsCode": "// Ensure we have binary.image for R2 upload.\n// Priority: keep existing binary.image → convert base64 → download from URL.\n// If none available, set __skipUpload=true and pass the item through.\n\nconst j = $json;\n\n// 1) Already have a binary? keep it\nif ($binary?.image) {\n  return [{ json: j, binary: $binary }];\n}\n\n// 2) Try known base64 fields\nlet b64 = j.extractedImageData || j.poseBase64 || j.characterBase64 || null;\n\nif (typeof b64 === 'string' && b64.length > 10) {\n  // Strip data URI prefix if present\n  let mime = 'image/png';\n  const m = b64.match(/^data:(image\\/[a-z0-9+.\\-]+);base64,(.*)$/i);\n  if (m) {\n    mime = m[1];\n    b64 = m[2];\n  }\n  const buf = Buffer.from(b64, 'base64');\n  const bin = await this.helpers.prepareBinaryData(\n    buf,\n    `${j.__meta?.poseNumber ?? 0}.png`,\n    mime\n  );\n  return [{ json: j, binary: { image: bin } }];\n}\n\n// 3) Try to download from a URL we already have\nconst url =\n  j.__meta?.characterPath ||\n  j.originalImageUrl ||\n  j.imageUrl ||\n  j.sourceUrl ||\n  null;\n\nif (typeof url === 'string' && /^https?:\\/\\//i.test(url)) {\n  const res = await this.helpers.request({\n    method: 'GET',\n    url,\n    encoding: null, // Buffer\n    gzip: true,\n  });\n  const bin = await this.helpers.prepareBinaryData(\n    Buffer.from(res),\n    `${j.__meta?.poseNumber ?? 0}.png`\n  );\n  return [{ json: j, binary: { image: bin } }];\n}\n\n// 4) Nothing available → mark and pass through (do NOT throw)\nj.__skipUpload = true;\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2016,
        7168
      ],
      "id": "828f3e96-f113-4ddc-83bc-9fadbeef804b",
      "name": "Make Binary from Base64"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "={{ $json.__meta.storageKey }}",
        "binaryPropertyName": "image",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -1408,
        7296
      ],
      "id": "445c4bbd-90b9-4508-9101-7649f6b49de0",
      "name": "Add Upload to R2",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Set Meta Path (final)\nconst j = $json;\nconst storageKey = j.__meta?.storageKey || null;\nconst didUpload = j.__meta?.didUpload === true;\n\n// Use bucket root; no folder prefix unless you put it inside storageKey.\nconst PUBLIC_BASE = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\n\nfunction joinUrl(base, key) {\n  if (!base || !key) return null;\n  const b = base.replace(/\\/+$/, '');\n  const k = String(key).replace(/^\\/+/, '');\n  return `${b}/${k}`;\n}\n\nif (storageKey && (didUpload || j.__meta?.characterPath == null)) {\n  j.__meta.characterPath = joinUrl(PUBLIC_BASE, storageKey);\n}\n\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        7392
      ],
      "id": "c3193b64-8ddb-471a-808d-5805606436e2",
      "name": "Set Meta Path"
    },
    {
      "parameters": {
        "url": "={{$json.__meta.characterPath}}",
        "options": {
          "response": {
            "response": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -288,
        7392
      ],
      "id": "fc3f85f5-b7d5-4417-bcec-bdb9a36d7dc6",
      "name": "Check Image URL (200)",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const probe = $items('Check Image URL (200)', 0, 0)[0]?.json;\nconst had200 = probe?.statusCode === 200 || probe?.status === 200;\n\nconst url = $json.__meta?.characterPath || null;\nconst b64 = $json.extractedImageData || null;\n\nreturn [{\n  json: {\n    ...$json,\n    _imageForBria: (had200 && url) ? url : b64,\n    _imageIsUrl: !!(had200 && url),\n    _urlCheckOk: !!had200,\n  },\n  binary: $input.first().binary,\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        7392
      ],
      "id": "f9a00bd6-e87a-4a7f-9a89-0a4f41ed69b2",
      "name": "URL OK or fallback to base64"
    },
    {
      "parameters": {
        "jsCode": "// Build Bria Payload — minimal & spec-safe\nconst j = $json;\n\n// Prefer the public URL we just built\nconst url =\n  j.__meta?.characterPath ||\n  j.characterPath ||\n  j.imageUrl ||\n  j.sourceUrl ||\n  null;\n\n// Optional base64 fallbacks\nlet b64 = j.extractedImageData || j.poseBase64 || j.characterBase64 || null;\nif (typeof b64 === 'string') {\n  const m = b64.match(/^data:(image\\/[a-z0-9+.\\-]+);base64,(.*)$/i);\n  if (m) b64 = m[2];\n  b64 = b64.trim();\n  if (b64.length < 12) b64 = null;\n}\n\n// Pose (numeric, for your logging)\nconst poseNumber =\n  j.__meta?.poseNumber ??\n  j.poseNumber ??\n  (Number.isFinite(Number(j.currentPoseNumber)) ? Number(j.currentPoseNumber) : 0);\n\n// Choose source (prefer URL)\nlet _briaBody;\nif (url) {\n  // Bria expects `image` as a STRING (URL)\n  _briaBody = { \n    image: url\n    // Note: pose_number NOT included - Bria API doesn't accept it\n  };\n} else if (b64) {\n  // Or `image` as base64 STRING\n  _briaBody = { \n    image: b64\n  };\n} else {\n  j.__meta = j.__meta || {};\n  j.__meta.__skipBria = true;\n  j.__meta.__skipReason = 'No usable image (no URL and no base64 present)';\n  delete j._briaBody;\n  return [{ json: j }];\n}\n\n// Store metadata separately (NOT sent to Bria)\nj.__meta = j.__meta || {};\nj.__meta.briaReady = true;\nj.__meta.briaSource = url ? 'url' : 'base64';\nj.__meta.poseNumber = poseNumber;\nj._briaBody = _briaBody;\n\n// Debug logging\nconsole.log(`Pose ${poseNumber}: Bria payload ready, source=${j.__meta.briaSource}`);\nconsole.log('_briaBody:', JSON.stringify(_briaBody));\n\nreturn [{ json: j }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        7232
      ],
      "id": "9272d6e7-b713-4ee2-9148-3200f665a11a",
      "name": "Build Bria Payload"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "fe658296-4c90-496b-a966-e8b551ef8f2e",
              "name": "poseNumber",
              "value": "={{ Number(String(($json.currentPoseNumber ?? $json.poseNumber ?? $json.__meta?.poseNumber ?? ($itemIndex + 1))).trim()) }}",
              "type": "number"
            },
            {
              "id": "cfda7178-43ff-49f0-95ca-00b43d4f87a9",
              "name": "R2_PUBLIC_BASE",
              "value": "https://pub-92cec53654f84771956bc84dfea65baa.r2.dev/little-hero-assets/",
              "type": "string"
            },
            {
              "id": "3e1d1930-1ea7-4095-9086-06c76fd55c4e",
              "name": "index",
              "value": "={{ Number($json.index ?? $itemIndex) }}",
              "type": "number"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2624,
        7392
      ],
      "id": "617c4b79-2149-4f58-a07a-5ec0091dccf3",
      "name": "Set Pose Index"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "39ba2fb9-75f8-42d5-b646-637dc74862b3",
              "leftValue": "={{ !$json.__skipUpload }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1760,
        7392
      ],
      "id": "b5e14f17-acc9-4733-a4d4-23d463e30bd2",
      "name": "If (should upload?)"
    },
    {
      "parameters": {
        "jsCode": "// Clean Binary After Upload (Function Item)\n// Assumes previous node is \"Attach Upload Response\" (Merge by position)\n\nconst out = { ...$json };\n\n// Normalize poseNumber -> number\nlet pose = out.currentPoseNumber ?? out.poseNumber ?? ($itemIndex + 1);\nif (typeof pose === 'string') pose = Number(pose.trim());\npose = Number(pose);\nout.poseNumber = pose;\nout.currentPoseNumber = pose;\n\n// Normalize index\nout.index = Number(out.index ?? $itemIndex);\n\n// Mark upload flags\nout.__meta = out.__meta || {};\nout.__meta.didUpload = true;\nif (out.__meta.poseNumber == null) out.__meta.poseNumber = pose;\n\n// Carry upload success if present\nif (typeof out.success !== 'undefined') out.upload_success = out.success;\n\n// Drop heavy fields if any leaked in\ndelete out.extractedImageData;\ndelete out.poseBase64;\ndelete out.characterBase64;\ndelete out.requestBody;\n\n// IMPORTANT: do not return $binary to keep memory low\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -704,
        7392
      ],
      "id": "b8e0b7cb-75f7-4308-999a-8eca7bfa370a",
      "name": "Clean Binary After Upload"
    },
    {
      "parameters": {
        "jsCode": "// No Upload Pass-through (prefer current item; no upstream lookups)\n// Use ONLY the current $json. Re-derive pose/index ONLY if missing.\n// This prevents resetting to pose=1 when earlier nodes exist.\n\nfunction parsePoseFromUrl(u) {\n  if (!u) return null;\n  const s = String(u);\n  const m = s.match(/\\/(\\d+)\\.(?:png|jpg|jpeg|webp)$/i);\n  return m ? Number(m[1]) : null;\n}\n\nconst out = { ...($json || {}) };   // keep exactly what came in\n\n// Pose: keep if present; otherwise derive from storageKey/url; last resort from index or $itemIndex\nlet pose = Number(\n  out.poseNumber ??\n  out.currentPoseNumber ??\n  out.__meta?.poseNumber ??\n  parsePoseFromUrl(out.__meta?.storageKey) ??\n  parsePoseFromUrl(out.originalImageUrl) ??\n  parsePoseFromUrl(out.imageUrl)\n);\n\nif (!Number.isFinite(pose) || pose < 1) {\n  pose = Number.isFinite(Number(out.index)) ? Number(out.index) + 1 : ($itemIndex + 1);\n}\n\n// If you always have 12 poses, clamp; otherwise remove this clamp.\nif (pose > 12) pose = 12;\n\n// Index: keep if present; else derive from pose\nlet idx = Number(out.index);\nif (!Number.isFinite(idx) || idx < 0) idx = pose - 1;\n\n// Normalize fields\nout.poseNumber = pose;\nout.currentPoseNumber = pose;\nout.index = idx;\n\nout.__meta = { ...(out.__meta || {}) };\nout.__meta.poseNumber = pose;\n\n// Do NOT touch urls/hashes or $binary; just forward\nreturn [{ json: out, binary: $binary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1200,
        7408
      ],
      "id": "a60ba390-9563-4994-b6b4-2141cfd26e23",
      "name": "No Upload Pass-through"
    },
    {
      "parameters": {
        "jsCode": "// Runs once over the whole array\nconst items = $input.all();\nreturn items.map((item, idx) => {\n  const j = { ...(item.json ?? {}) };\n\n  // If caller provided a pose, keep it; otherwise assign 1..N\n  j.poseNumber        = j.poseNumber ?? j.currentPoseNumber ?? (idx + 1);\n  j.currentPoseNumber = j.currentPoseNumber ?? j.poseNumber;\n\n  // Optional helper, zero-based\n  j.index = j.index ?? idx;\n\n  return { json: j, binary: item.binary };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3696,
        7392
      ],
      "id": "bb2299e2-a802-4fe6-a81c-2cd581675618",
      "name": "Stamp Pose Index"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1200,
        7184
      ],
      "id": "0f85e1ca-b194-442f-8e6a-79e43c0e7274",
      "name": "Merge"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        928,
        7248
      ],
      "id": "5ebc068f-b5fc-4348-a736-70bde865c153",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// Build Stamp Pose Index-compatible items from small inputs + downloaded binary\n// Downstream expects: array of items where item.json has\n// poseNumber (1-based), currentPoseNumber (same), index (0-based),\n// and the Gemini-style `candidates[0].content.parts[0].inlineData` payload.\n\nconst items = $input.all();\n\nreturn items.map((item, idx) => {\n  const j = item.json ?? {};\n  const bin = item.binary ?? {};\n\n  // derive/normalize indices\n  const pose = Number.isFinite(Number(j.poseNumber)) ? Number(j.poseNumber) : (idx + 1);\n  const index = Number.isFinite(Number(j.index)) ? Number(j.index) : idx;\n\n  // n8n stores binary as base64 string at {binaryKey}.data\n  const b = bin.data;\n  if (!b?.data) {\n    throw new Error(\"Binary 'data' missing. Ensure HTTP Request returned a File with binary property 'data'.\");\n  }\n\n  const out = {\n    ...j,\n    poseNumber: pose,\n    currentPoseNumber: pose,\n    index,\n    candidates: [\n      {\n        content: {\n          parts: [\n            {\n              inlineData: {\n                mimeType: b.mimeType || \"image/png\",\n                data: b.data // base64 string\n              }\n            }\n          ]\n        }\n      }\n    ]\n  };\n\n  // Keep binary if you want (not necessary for most downstream nodes)\n  return { json: out, binary: item.binary };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3280,
        7168
      ],
      "id": "1b852752-2d62-4b5d-80b6-3ea7b7267091",
      "name": "Build Stamp Pose Output (Sim)"
    },
    {
      "parameters": {
        "url": "={{$json.imageUrl}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3472,
        7168
      ],
      "id": "260d1510-82af-4f7c-9189-4de6472ac1cd",
      "name": "Download Image"
    },
    {
      "parameters": {
        "jsCode": "// Capture Lean Meta (Sim Safe)\n// Works even if \"Generate Character Hash\" never ran.\n// Derives pose, hash, storageKey, and characterPath from the simulated item.\n// Also propagates amazonOrderId (default TEST-ORDER-002).\n\nconst src = ($input.first()?.json) || {};\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_AMZ_ID = 'TEST-ORDER-002';\n\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// ---- helpers ----\nfunction tryHashFromNode() {\n  try {\n    return $items('Generate Character Hash', 0, 0)?.[0]?.json?.characterHash ?? null;\n  } catch { return null; }\n}\n\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try {\n    const path = new URL(u).pathname;               // '/.../characters/<hash>/<pose>.png'\n    return path.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  } catch {\n    return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  }\n}\n\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, ''); // drop filename to get folder path\n}\n\n// ---- 0) Amazon Order ID (propagate strongly) ----\nconst amazonOrderId =\n  src.orderData?.amazonOrderId ??\n  src.amazonOrderId ??\n  src.__meta?.amazonOrderId ??\n  DEFAULT_AMZ_ID;\n\n// ---- 1) Pose number (keep 1-based; clamp 1..12) ----\nconst poseNumberRaw =\n  src.poseNumber ??\n  src.currentPoseNumber ??\n  src.__meta?.poseNumber ??\n  ($itemIndex + 1);\n\nconst poseParsed = Number.isFinite(Number(poseNumberRaw)) ? Number(poseNumberRaw) : 1;\nconst poseNumber = Math.min(12, Math.max(1, Number(poseParsed)));\n\n// ---- 2) Character hash (prefer simulated fields; fall back to URL; last to node) ----\nconst upstreamHash   = tryHashFromNode();\nconst urlHash        = hashFromUrl(src.originalImageUrl || src.imageUrl);\nconst resolvedHash   = src.characterHash || src.characterSpecs?.hash || urlHash || upstreamHash || null;\nconst characterHash  = isBadHash(resolvedHash) ? null : resolvedHash;\n\n// ---- 3) Path & storageKey ----\nlet characterPath =\n  src.__meta?.characterPath ||\n  src.characterPath ||\n  folderFromUrl(src.originalImageUrl || src.imageUrl) ||\n  (characterHash ? `${BASE_PREFIX}/${characterHash}/` : null);\n\nconst storageKey = characterHash\n  ? `${BASE_PREFIX}/${characterHash}/${poseNumber}.png`\n  : null;\n\n// ---- 4) Write meta + top-level fields back ----\nsrc.amazonOrderId = amazonOrderId; // flat\nsrc.orderData = { ...(src.orderData || {}), amazonOrderId }; // nested for compatibility\n\nsrc.__meta = {\n  ...(src.__meta || {}),\n  amazonOrderId,     // keep in meta for easy access\n  poseNumber,        // 1..12\n  characterHash,     // may be null in extreme sim cases\n  storageKey,        // null if no hash\n  characterPath      // stable folder-style path (no domain)\n};\n\nreturn [{ json: src }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2352,
        7392
      ],
      "id": "43f73e8f-a6f8-49b0-99e8-547b9ccd094c",
      "name": "FOR TESTING - Capture Lean Meta"
    },
    {
      "parameters": {
        "jsCode": "// Store Submission Result (Sim Safe) — with raw file URL\n// Works without Bria/Generate Character Hash. Safe for simulated inputs.\n// Now also carries amazonOrderId (default TEST-ORDER-002).\n\n// --- Constants (keep in sync across nodes)\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_AMZ_ID = 'TEST-ORDER-002';\n\n// --- Gather inputs (usually just your Sim Image Index item)\nconst inputs = $input.all();\n\n// --- Helpers\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try {\n    const path = new URL(u).pathname; // '/.../characters/<hash>/<pose>.png'\n    return path.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  } catch {\n    return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  }\n}\n\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, ''); // drop filename → folder\n}\n\nfunction pickMetaItem() {\n  return inputs.find(i => i?.json?.__meta) || inputs[0];\n}\nfunction pickRespItem() {\n  return inputs.find(i => {\n    const j = i?.json || {};\n    return j.request_id || j.requestId || j.status_url || j.statusUrl ||\n           j.data?.request_id || j.result?.request_id || j.links?.status;\n  }) || inputs[0];\n}\n\n// --- Identify items (meta/resp may be the same in sim)\nconst metaItem = pickMetaItem();\nconst respItem = pickRespItem();\nconst meta = metaItem?.json?.__meta || {};\nconst resp = respItem?.json || {};\n\n// --- Amazon Order ID (prefer nested/flat/meta; default to TEST)\nconst amazonOrderId =\n  metaItem?.json?.orderData?.amazonOrderId ??\n  metaItem?.json?.amazonOrderId ??\n  meta?.amazonOrderId ??\n  DEFAULT_AMZ_ID;\n\n// --- Pose number (prefer meta/local; clamp 1..12)\nconst rawPose =\n  meta.poseNumber ??\n  metaItem?.json?.poseNumber ??\n  metaItem?.json?.currentPoseNumber ??\n  respItem?.json?.poseNumber ??\n  respItem?.json?.currentPoseNumber ??\n  1;\n\nconst poseParsed = Number.isFinite(Number(rawPose)) ? Number(rawPose) : 1;\nconst poseNumber = Math.min(12, Math.max(1, Number(poseParsed)));\n\n// --- Try to resolve a raw file URL from the sim inputs\nconst simSourceUrl =\n  metaItem?.json?.originalImageUrl || metaItem?.json?.imageUrl ||\n  respItem?.json?.originalImageUrl || respItem?.json?.imageUrl || null;\n\n// --- Resolve characterHash (prefer explicit, then from URL)\nconst localHash =\n  meta.characterHash ??\n  metaItem?.json?.characterHash ??\n  respItem?.json?.characterHash ??\n  metaItem?.json?.characterSpecs?.hash ??\n  respItem?.json?.characterSpecs?.hash ??\n  hashFromUrl(simSourceUrl) ??\n  null;\n\nconst characterHash = isBadHash(localHash) ? null : localHash;\n\n// --- characterPath (folder-style); backfill if missing\nlet characterPath =\n  meta.characterPath ??\n  metaItem?.json?.characterPath ??\n  respItem?.json?.characterPath ??\n  folderFromUrl(simSourceUrl) ??\n  (characterHash ? `${BASE_PREFIX}/${characterHash}/` : null);\n\n// --- Bria response identifiers (fabricate in sim mode if missing)\nlet requestId =\n  resp.request_id ?? resp.requestId ??\n  resp.data?.request_id ?? resp.result?.request_id ?? null;\n\nlet statusUrl =\n  resp.status_url ?? resp.statusUrl ??\n  resp.data?.status_url ?? resp.result?.status_url ??\n  resp.links?.status ?? null;\n\nif (!requestId) {\n  const hashForId = characterHash || 'sim';\n  requestId = `sim-${hashForId}-${poseNumber}`;\n}\nif (!statusUrl && simSourceUrl) {\n  statusUrl = simSourceUrl; // stand-in so downstream nodes have something resolvable\n}\n\n// In simulation we want success semantics; only fail if we truly have nothing\nconst failed = !(requestId && (statusUrl || characterHash || characterPath));\n\n// --- Output (now includes imageUrl & originalImageUrl and amazonOrderId)\nconst out = {\n  requestId,\n  statusUrl,\n  poseNumber,\n  characterHash,\n  characterPath,        // folder-style path (no filename)\n  imageUrl: simSourceUrl || null,\n  originalImageUrl: simSourceUrl || null,\n  amazonOrderId,        // ← NEW: carried forward\n  failed,\n  submittedAt: new Date().toISOString(),\n};\n\n// Diagnostics (optional)\nconsole.log(`SimSafe store: pose=${poseNumber}, id=${requestId}, failed=${failed}, amazonOrderId=${amazonOrderId}`);\n\nreturn [{ json: out }];\n"
      },
      "id": "7e2df765-8021-40bc-bf0c-d8277894c64e",
      "name": "FOR TESTING - Store Submission Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1232,
        7440
      ]
    },
    {
      "parameters": {
        "jsCode": "// === CREATE FINAL SUMMARY (TEST) — no cross-node references ===\n// Uses only the incoming items (e.g., from Sim Image Index / Sim Safe Store) to\n// build orderData and submissions. Safe for runs where Capture Lean Meta /\n// Generate Character Hash are skipped.\n\nconst incomingItems = $input.all();\nconsole.log('=== CREATE FINAL SUMMARY (TEST) ===');\nconsole.log(`Received ${incomingItems.length} items from loop`);\n\nconst SIM_AMAZON_ORDER_ID = 'TEST-ORDER-LOCAL-001';\n\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try {\n    const path = new URL(u).pathname; // '/.../characters/<hash>/<pose>.png'\n    return path.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  } catch {\n    return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null;\n  }\n}\n\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, ''); // drop filename → folder\n}\n\n// ---- Helpers to derive globals from ONLY incoming items ----\nfunction chooseGlobalHash(items) {\n  for (const it of items) {\n    const j = it?.json || {};\n    const candidate =\n      j.characterHash ??\n      j.__meta?.characterHash ??\n      j.characterSpecs?.hash ??\n      hashFromUrl(j.originalImageUrl || j.imageUrl) ??\n      null;\n    if (!isBadHash(candidate)) return candidate;\n  }\n  return null;\n}\n\nfunction chooseAmazonOrderId(items) {\n  for (const it of items) {\n    const j = it?.json || {};\n    const id =\n      j.orderData?.amazonOrderId ??\n      j.amazonOrderId ??\n      null;\n    if (id && String(id).trim().length > 0) return String(id).trim();\n  }\n  return SIM_AMAZON_ORDER_ID; // fallback for simulation\n}\n\n// Prefer any embedded order snapshot if present, else minimal structure\nconst firstJson = incomingItems?.[0]?.json || {};\nconst globalHash = chooseGlobalHash(incomingItems);\nconst amazonOrderId = chooseAmazonOrderId(incomingItems);\n\nconst orderData = {\n  // AMAZON ORDER: now guaranteed (sim default if absent)\n  amazonOrderId,\n\n  // Hash: prefer embedded, else global derived from URLs/fields\n  characterHash: !isBadHash(firstJson.orderData?.characterHash)\n                    ? firstJson.orderData.characterHash\n                    : (!isBadHash(firstJson.characterHash)\n                        ? firstJson.characterHash\n                        : globalHash),\n\n  characterSpecs: firstJson.orderData?.characterSpecs ?? firstJson.characterSpecs ?? {},\n  bookSpecs:      firstJson.orderData?.bookSpecs ?? firstJson.bookSpecs ?? {},\n  orderDetails:   firstJson.orderData?.orderDetails ?? firstJson.orderDetails ?? {},\n  r2BucketName:   firstJson.orderData?.r2BucketName ?? 'little-hero-assets'\n};\n\nconsole.log('Order data snapshot (TEST):', {\n  amazonOrderId: orderData.amazonOrderId,\n  characterHash: orderData.characterHash || 'null'\n});\n\n// ---- Build normalized submissions array (prefer item hash; fallback to order hash)\nconst submissions = incomingItems.map((item, idx) => {\n  const j = item.json || {};\n\n  const pose =\n    Number(j.poseNumber) ||\n    Number(j.currentPoseNumber) ||\n    (idx + 1);\n\n  const itemHash =\n    j.characterHash ??\n    j.__meta?.characterHash ??\n    j.characterSpecs?.hash ??\n    hashFromUrl(j.originalImageUrl || j.imageUrl) ??\n    null;\n\n  const chosenHash = !isBadHash(itemHash)\n    ? itemHash\n    : (!isBadHash(orderData.characterHash) ? orderData.characterHash : null);\n\n  // characterPath: prefer explicit/meta; otherwise derive from the file URL\n  let path =\n    j.__meta?.characterPath ??\n    j.characterPath ??\n    j.sourceUrl ??\n    null;\n\n  if (!path) {\n    const rawUrl = j.originalImageUrl || j.imageUrl || null;\n    if (rawUrl) path = folderFromUrl(rawUrl); // folder-style\n  }\n\n  const briaSubmissionSuccess = !!(j.requestId && j.statusUrl);\n  return {\n    requestId: j.requestId || null,\n    statusUrl: j.statusUrl || null,\n\n    // keep for compatibility/diagnostics\n    extractedImageData: j.extractedImageData || null,\n\n    // pose\n    currentPoseNumber: pose,\n    poseNumber: pose,\n\n    // id & pathing\n    characterHash: chosenHash || null,\n    characterPath: path || null,\n\n    // raw file references if present (harmless if null)\n    imageUrl: j.imageUrl || null,\n    originalImageUrl: j.originalImageUrl || null,\n\n    failed: !!j.failed,\n    submittedAt: j.submittedAt || new Date().toISOString(),\n    briaSubmissionSuccess\n  };\n});\n\nconst valid = submissions.filter(s => s.requestId && s.statusUrl);\nconst failed = submissions.length - valid.length;\n\nconsole.log(`Valid submissions: ${valid.length}`);\nconsole.log(`Failed submissions: ${failed}`);\nconsole.log(`Pose numbers: ${submissions.map(s => s.poseNumber).join(', ')}`);\n\nreturn [{\n  json: {\n    totalSubmissions: submissions.length,\n    successful: valid.length,\n    failed: failed,\n    submittedAt: new Date().toISOString(),\n\n    submissions,\n    orderData,           // preserved for 2B/next workflow\n    workflow2AComplete: true\n  }\n}];\n"
      },
      "id": "52416753-d4dc-4217-8f9b-a19760ddff67",
      "name": "FOR TESTING - Create Final Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2576,
        6976
      ]
    },
    {
      "parameters": {
        "jsCode": "// Sim Image Indexes + hash for Capture Lean Meta\n// Mode: Run Once for All Items  |  Language: JavaScript\n\n// ---- EDIT THESE CONSTANTS ----\nconst CHARACTER_HASH = '1dde0fac84943088';\nconst PUBLIC_BASE = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev/book-mvp-simple-adventure/order-generated-assets/characters';\nconst AMAZON_ORDER_ID = 'TEST-ORDER-002'; // ← NEW\n// --------------------------------\n\nconst COUNT = 12;\n\nreturn Array.from({ length: COUNT }, (_, i) => {\n  const poseNumber = i + 1;\n  const url = `${PUBLIC_BASE}/${CHARACTER_HASH}/${poseNumber}.png`;\n\n  return {\n    json: {\n      // what downstream nodes expect for indexing\n      poseNumber,         // 1..12\n      index: i,           // 0-based\n\n      // image URL so preview/downstream still works\n      imageUrl: url,\n      originalImageUrl: url, // some nodes read this key\n\n      // provide the hash so Capture Lean Meta can build storageKey/characterPath\n      characterHash: CHARACTER_HASH,\n\n      // belt-and-suspenders: CLM also checks this location\n      characterSpecs: { hash: CHARACTER_HASH },\n\n      // test Amazon Order ID (set both flat and nested for compatibility)\n      amazonOrderId: AMAZON_ORDER_ID,\n      orderData: { amazonOrderId: AMAZON_ORDER_ID },\n\n      // optional hint; CLM will merge/overwrite as needed\n      __meta: { poseNumber, amazonOrderId: AMAZON_ORDER_ID }\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3648,
        7168
      ],
      "id": "13875e52-122e-4d19-b5a7-f96ff95788a6",
      "name": "Stamp Pose Index Simulation"
    }
  ],
  "pinData": {},
  "connections": {
    "Generate Mock Order": {
      "main": [
        [
          {
            "node": "Get Next Order from Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Stamp Pose Index Simulation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Character in Pose": {
      "main": [
        [
          {
            "node": "Extract Generated Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Generated Image": {
      "main": [
        [
          {
            "node": "DIAGNOSTIC: Check Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DIAGNOSTIC: Check Fields": {
      "main": [
        [
          {
            "node": "Filter: Only Items With Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter: Only Items With Images": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Next Order from Queue": {
      "main": [
        [
          {
            "node": "Generate Character Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Character Hash": {
      "main": [
        [
          {
            "node": "Load Reference Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Reference Image": {
      "main": [
        [
          {
            "node": "Prepare binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Custom Base Character": {
      "main": [
        [
          {
            "node": "Process Gemini API response and extract generated image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare binary": {
      "main": [
        [
          {
            "node": "Generate Custom Base Character",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Gemini API response and extract generated image": {
      "main": [
        [
          {
            "node": "Upload a file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload a file": {
      "main": [
        [
          {
            "node": "Restore Metadata After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Metadata After Upload": {
      "main": [
        [
          {
            "node": "Load Custom Character from R2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Custom Character from R2": {
      "main": [
        [
          {
            "node": "Initialize Pose Generation Loop",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Pose Generation Loop": {
      "main": [
        [
          {
            "node": "Load Pose Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Pose Reference": {
      "main": [
        [
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Character with Poses": {
      "main": [
        [
          {
            "node": "Reorganize Merged Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reorganize Merged Data": {
      "main": [
        [
          {
            "node": "Prepare Gemini Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gemini Requests": {
      "main": [
        [
          {
            "node": "Generate Character in Pose",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Stamp Pose Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [
          {
            "node": "FOR TESTING - Create Final Summary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Set Pose Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Submit to Bria AI": {
      "main": [
        [
          {
            "node": "Drop Heavy Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Submission Result": {
      "main": [
        [
          {
            "node": "Wait 6 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 6 Seconds": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Final Summary": {
      "main": [
        [
          {
            "node": "Wait 90 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 90 Seconds": {
      "main": [
        [
          {
            "node": "Trigger Workflow B",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Drop Heavy Fields": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Capture Lean Meta": {
      "main": [
        [
          {
            "node": "Make Binary from Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Make Binary from Base64": {
      "main": [
        [
          {
            "node": "If (should upload?)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Upload to R2": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Set Meta Path": {
      "main": [
        [
          {
            "node": "Check Image URL (200)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Image URL (200)": {
      "main": [
        [
          {
            "node": "URL OK or fallback to base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "URL OK or fallback to base64": {
      "main": [
        [
          {
            "node": "Build Bria Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Bria Payload": {
      "main": [
        [
          {
            "node": "Submit to Bria AI",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Pose Index": {
      "main": [
        [
          {
            "node": "FOR TESTING - Capture Lean Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (should upload?)": {
      "main": [
        [
          {
            "node": "Add Upload to R2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Upload Pass-through",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Binary After Upload": {
      "main": [
        [
          {
            "node": "Set Meta Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Upload Pass-through": {
      "main": [
        [
          {
            "node": "Clean Binary After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stamp Pose Index": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Clean Binary After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "FOR TESTING - Store Submission Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Stamp Pose Output (Sim)": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Image": {
      "main": [
        [
          {
            "node": "Build Stamp Pose Output (Sim)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Capture Lean Meta": {
      "main": [
        [
          {
            "node": "Make Binary from Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Store Submission Result": {
      "main": [
        [
          {
            "node": "Wait 6 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Create Final Summary": {
      "main": [
        [
          {
            "node": "Wait 90 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stamp Pose Index Simulation": {
      "main": [
        [
          {
            "node": "Download Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "004531ba-a6d2-4aca-85b7-1532b9d542e1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "010748b7a1466c46dced3f8b2bdbc3bc174722f0672e5a4c9529354f5ff306f8"
  },
  "id": "jZaJkKT9LRF6SfDC",
  "tags": []
}