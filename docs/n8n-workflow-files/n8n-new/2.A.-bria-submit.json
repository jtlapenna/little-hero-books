{
  "name": "LHB - 2.A.- CHARACTER CREATION - WORKING NEW with PROMPT ENGINEERING",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Generate a mock order for testing the AI character generation workflow\n// This simulates an order coming from the order intake workflow\n\nconst mockOrder = {\n  amazonOrderId: 'TEST-ORDER-003',\n  status: 'queued_for_processing',\n  orderDate: new Date().toISOString(),\n  customerEmail: 'test@example.com',\n  characterSpecs: {\n    childName: 'Alex',\n    skinTone: 'tan',\n    hairColor: 'dark-brown',\n    hairStyle: 'curly-long',\n    age: 5,\n    pronouns: 'she/her',\n    favoriteColor: 'pink',\n    animalGuide: 'tiger',\n    clothingStyle: 'dress'\n  },\n  bookSpecs: {\n    title: 'Alex and the Adventure Compass',\n    totalPages: 16,\n    format: '8.5x8.5_softcover',\n    bookType: 'animal-guide' // or 'mvp-simple' for different book types\n  },\n  orderDetails: {\n    quantity: 1,\n    shippingAddress: {\n      name: 'Test Customer',\n      address: '123 Test Street',\n      city: 'Test City',\n      state: 'CA',\n      zip: '90210'\n    }\n  }\n};\n\nconsole.log('Generated mock order for testing:', mockOrder);\nreturn [{ json: mockOrder }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7984,
        7376
      ],
      "id": "3cd79a41-e7d7-4d0b-9d27-8cb3b799f2a0",
      "name": "Generate Mock Order"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -8288,
        7184
      ],
      "id": "a6a9edf7-03dd-408c-8237-994970224c0a",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "functionCode": "// Get next order from processing queue and extract custom elements\n// In production, this would query a database queue\n// For now, we'll simulate getting an order from the previous workflow\n\nconst inputData = $input.first();\nif (!inputData || !inputData.json) {\n  console.log('No input data received');\n  return [];\n}\n\nconst orderData = inputData.json;\n\n// Check if order is ready for AI generation\nif (orderData.status !== 'queued_for_processing') {\n  console.log(`Order ${orderData.amazonOrderId} not ready for processing. Status: ${orderData.status}`);\n  return [];\n}\n\n// Extract and validate custom elements from characterSpecs\nconst characterSpecs = orderData.characterSpecs || {};\nconst customElements = {\n  childName: characterSpecs.childName || 'Adventure Hero',\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Update order status to processing with custom elements\nconst processingOrder = {\n  ...orderData,\n  characterSpecs: customElements,\n  status: 'ai_generation_in_progress',\n  aiGenerationStartedAt: new Date().toISOString(),\n  posesGenerated: 0,\n  totalPosesRequired: 12,\n  generationProgress: 0\n};\n\nconsole.log(`Starting AI generation for order: ${orderData.amazonOrderId}`);\nconsole.log(`Custom elements:`, customElements);\nreturn [{ json: processingOrder }];"
      },
      "id": "a726392c-27c0-4bee-b6da-dc60cdffcb3d",
      "name": "Get Next Order from Queue",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -7792,
        7376
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate character hash for reuse detection\nconst orderData = $input.first().json;\nconst characterSpecs = orderData.characterSpecs || {};\n\n// Create a normalized character specification object for hashing\nconst characterHashSpec = {\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Generate a deterministic hash from the character specifications\nconst crypto = require('crypto');\nconst hashString = JSON.stringify(characterHashSpec, Object.keys(characterHashSpec).sort());\nconst characterHash = crypto.createHash('sha256').update(hashString).digest('hex').substring(0, 16);\n\n// Add character hash and normalized specs to order data\nconst orderWithHash = {\n  ...orderData,\n  characterHash: characterHash,\n  characterHashSpec: characterHashSpec,\n  characterPath: `characters/${characterHash}`,\n  templatePath: 'templates'\n};\n\nconsole.log(`Generated character hash: ${characterHash}`);\nconsole.log(`Character specs:`, characterHashSpec);\n\nreturn [{ json: orderWithHash }];"
      },
      "id": "4bc3dad0-594f-4e6d-b223-820c96df90ab",
      "name": "Generate Character Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7616,
        7376
      ]
    },
    {
      "parameters": {
        "jsCode": "// Restore metadata after S3 upload\nconst uploadResult = $input.first();\nconst originalData = $('Process Gemini API response and extract generated image').first();\n\nreturn [{\n  json: {\n    ...originalData.json,\n    s3UploadResult: uploadResult.json,\n    baseCharacterUploaded: true,\n    baseCharacterUploadedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "68da8c62-178f-412a-8ac4-c3362d161cbb",
      "name": "Restore Metadata After Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5120,
        7392
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize pose generation loop\nconst orderData = $input.first().json;\n\nconst existingPoses = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n\nconsole.log(`Using existing poses: ${existingPoses.join(', ')}`);\n\nconst posesToGenerate = existingPoses.map(poseNumber => ({\n  ...orderData,\n  currentPoseNumber: poseNumber,\n  poseStatus: 'pending',\n  poseGenerationAttempts: 0,\n  maxPoseAttempts: 3\n}));\n\nconsole.log(`Initialized pose generation for ${posesToGenerate.length} poses`);\nreturn posesToGenerate.map(pose => ({ json: pose }));"
      },
      "id": "e7346535-a7c8-4da8-a31b-ea18875b63bb",
      "name": "Initialize Pose Generation Loop",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -4672,
        7472
      ]
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.characterPath }}/base-character.png"
      },
      "id": "9d8cc39c-ea54-4795-91cc-13b9d4550c72",
      "name": "Load Custom Character from R2",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -4896,
        7392
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "=book-mvp-simple-adventure/characters/poses/pose{{ $json.currentPoseNumber.toString().padStart(2, '0') }}.png"
      },
      "id": "56137ecc-a731-4e18-aae1-c0905b0f7cbe",
      "name": "Load Pose Reference",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -4448,
        7472
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {},
      "id": "b8035b9e-abd6-4b42-a67e-bc278c187eea",
      "name": "Merge Character with Poses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -4224,
        7408
      ]
    },
    {
      "parameters": {
        "jsCode": "// Reorganize merged data: duplicate character across all pose items\n// — Robust pose stamping from incoming pose filenames (prevents pose=1 overwrite)\n\nconst items = $input.all(); // expected: [0] = character, [1..12] = poses\nconst loopItems = $('Initialize Pose Generation Loop').all(); // carries order/specs per pose\nconst characterLoadItem = $('Load Custom Character from R2').first();\n\nif (items.length !== 13) {\n  throw new Error(`Expected 13 items (1 character + 12 poses), got ${items.length}`);\n}\n\n// Character (item 0) → base64 once\nconst characterBuffer = await this.helpers.getBinaryDataBuffer(0, 'data');\nconst characterBase64 = characterBuffer.toString('base64');\nif (!characterBase64 || characterBase64.length < 100) {\n  throw new Error('Invalid character binary');\n}\n\n// Character context from loader\nconst characterPath = characterLoadItem.json.characterPath;\nconst characterHash = characterLoadItem.json.characterHash;\n\n// Helper: parse pose number from a filename/URL/snippet\nfunction parsePoseFromString(s) {\n  if (!s) return null;\n  const str = String(s);\n  // Matches: pose01 / pose-01 / _01 / -01 / /01.png (at end)\n  const m = str.match(/(?:pose[_\\- ]?(\\d{1,2}))|[_\\-\\.](\\d{1,2})(?:\\D|$)|\\/(\\d{1,2})\\.png$/i);\n  if (!m) return null;\n  return Number(m[1] || m[2] || m[3]);\n}\n\nconst results = [];\nconst seen = new Set();\n\nfor (let i = 1; i < items.length; i++) {\n  const poseItem = items[i];\n  const loopItem = loopItems[i - 1] || { json: {} };\n\n  // Pose image → base64\n  const poseBuffer = await this.helpers.getBinaryDataBuffer(i, 'data');\n  const poseBase64 = poseBuffer.toString('base64');\n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Invalid pose binary for item ${i}`);\n  }\n\n  // Derive pose number from filename (authoritative), with safe fallback to index\n  const poseFileName =\n    poseItem.binary?.data?.fileName ||\n    poseItem.binary?.data?.fileName ||\n    `pose${String(i).padStart(2, '0')}.png`;\n\n  let poseNum =\n    loopItem.json.poseNumber ??\n    loopItem.json.currentPoseNumber ??\n    parsePoseFromString(poseFileName) ??\n    i; // fallback to position (1-based)\n\n  poseNum = Math.min(12, Math.max(1, Number(poseNum)));\n  const posePadded = String(poseNum).padStart(2, '0');\n\n  // Guard against duplicates (shouldn’t happen, but protects from overwrites)\n  if (seen.has(poseNum)) {\n    throw new Error(`Duplicate poseNumber detected (${poseNum}) — check upstream pose inputs/ordering.`);\n  }\n  seen.add(poseNum);\n\n  results.push({\n    json: {\n      // carry through loop/order/specs\n      ...loopItem.json,\n\n      // base/pose inputs for Gemini\n      characterBase64,\n      poseBase64,\n\n      // stable character context\n      characterPath,\n      characterHash,\n\n      // authoritative pose fields\n      poseRefName: poseFileName,\n      poseNumber: poseNum,\n      currentPoseNumber: poseNum,\n      index: poseNum - 1, // optional helper\n\n      // breadcrumb for debugging\n      __reorg: { fromIndex: i, poseFileName }\n    }\n    // (no need to pass binary once we’ve encoded base64)\n  });\n}\n\nreturn results;\n"
      },
      "id": "88ec207d-787f-4f26-b319-57ecdaad9bc4",
      "name": "Reorganize Merged Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3984,
        7408
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Gemini API request for POSE images with explicit positives/negatives + safety net + pose-specific prop allowlist\n// NOTE: Do NOT include correlationId in the POST body; keep it on the item only.\n\nconst items = $input.all();\nconst results = [];\n\n// Shared, identical config for every call in this run\nconst generationConfig = {\n  imageConfig: { aspectRatio: \"1:1\" },\n  temperature: 0.3,\n};\n\n// Optional pose grammar table (keep off for now to isolate changes)\nconst USE_POSE_GRAMMAR = false;\nconst POSE_TEXT = {\n  \"1\": \"Neutral stance: weight even, shoulders level, arms relaxed at sides, head forward.\",\n  \"2\": \"Walking step: weight on rear leg, front leg forward, opposite arm swing.\",\n  \"3\": \"Hands on hips: elbows out, shoulders back, feet shoulder-width apart.\",\n  // …add as needed\n};\n\n// ✅ NEW: Pose-specific prop allow-list (keeps global 'no props' while allowing exceptions)\nconst POSE_ALLOWED_PROPS = {\n  \"7\": [\"sandwich\"],   // Pose 7: allow a simple sandwich prop\n  // Add other pose exceptions here as needed\n};\n\n// --- helpers ---\nfunction parsePoseFromString(s) {\n  if (!s) return null;\n  const str = String(s);\n  // matches: pose01 / pose-01 / _01 / -01 / /01.png (end)\n  const m = str.match(/(?:pose[_\\- ]?(\\d{1,2}))|[_\\-\\.](\\d{1,2})(?:\\D|$)|\\/(\\d{1,2})\\.png$/i);\n  if (!m) return null;\n  return Number(m[1] || m[2] || m[3]);\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const j = item.json || {};\n\n  // --- SAFETY NET: resolve poseNumber robustly (no idx/$itemIndex fallback) ---\n  let poseNum = j.poseNumber ?? j.currentPoseNumber ?? j.__meta?.poseNumber ?? null;\n  if (!Number.isFinite(Number(poseNum))) {\n    const candidates = [\n      j.poseRefName, j.poseRefFilename, j.poseRef, j.poseFileName,\n      j.poseRefUrl, j.poseUrl, j.posePath,\n      j.characterPath, j.imageUrl, j.sourceUrl\n    ];\n    for (const c of candidates) {\n      const parsed = parsePoseFromString(c);\n      if (Number.isFinite(parsed)) { poseNum = parsed; break; }\n    }\n  }\n  if (!Number.isFinite(Number(poseNum))) {\n    throw new Error('Prepare Gemini (pose): poseNumber missing/invalid — aborting to prevent filename overwrites.');\n  }\n  poseNum = Math.min(12, Math.max(1, Number(poseNum)));\n\n  // Required inputs\n  const characterBase64 = j.characterBase64;\n  const poseBase64 = j.poseBase64;\n  if (!characterBase64 || characterBase64.length < 100) {\n    throw new Error(`Character base64 data missing or invalid for pose ${poseNum}`);\n  }\n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Pose base64 data missing or invalid for pose ${poseNum}`);\n  }\n\n  const cs = j.characterSpecs || {};\n  const characterHash = j.characterHash || cs.hash || 'nohash';\n  const correlationId = `${characterHash}-${poseNum}-${Date.now()}`; // keep on item only\n\n  // Determine props allowed for this pose (if any)\n  const allowedProps = POSE_ALLOWED_PROPS[String(poseNum)] || [];\n\n  const systemText = [\n    'You are a precise illustration tool.',\n    'CRITICAL: Preserve the EXACT appearance from IMAGE A. IMAGE B is ONLY for body position.',\n    'CONFLICT RULE: If appearance (A) and pose (B) conflict, ALWAYS follow A and reinterpret B.',\n    '',\n    'HAIR OUTPUT POLICY:',\n    '- Hair must render as a SINGLE, OPAQUE MASS (one connected silhouette).',\n    '- No gaps, holes, or see-through spaces between strands.',\n    '- No wispy flyaway hairs, stray single-hair lines, or motion blur.',\n    '- Edges must be clean and closed (anti-aliased OK), with NO interior pinholes.',\n    '- Do NOT add halos, outer glows, outlines, or transparency on hair.'\n  ].join('\\n');\n\n  // NEGATIVES: forbid props by default, but allow the pose-specific exceptions listed below\n  const negativesBlock = [\n    'NEGATIVES — DO NOT DO THIS:',\n    '- Do NOT borrow clothing, facial features, hair details, or colors from IMAGE B.',\n    '- Do NOT change hair silhouette, clothing palette, or facial proportions from IMAGE A.',\n    '- Do NOT add text or background elements.',\n    '- Do NOT add props EXCEPT those explicitly listed in ALLOWED PROPS below.'\n  ].join('\\n');\n\n  const positivesBlock = [\n    'POSITIVES — DO THIS:',\n    '- Use IMAGE A as the sole source of appearance (face, hair, skin, clothing, proportions).',\n    '- Use IMAGE B only for body posture and limb orientation.',\n    '- Render hair as a single, continuous, opaque silhouette suitable for background removal.',\n    '- Keep background pure white (#FFFFFF).'\n  ].join('\\n');\n\n  // HAIRSTYLE LOCK (e.g., ponytail)\n  const hairStyleLower = (cs.hairStyle || '').toLowerCase();\n  let hairstyleLock = '';\n  if (hairStyleLower.includes('ponytail')) {\n    hairstyleLock = [\n      'HAIRSTYLE LOCK — PONYTAIL:',\n      '- Hair is tied back in a single ponytail; a visible tie gathers the hair.',\n      '- No loose/free-flowing hair around face, shoulders, or back.',\n      '- The ponytail tail sits behind the head/neck; silhouette remains one connected mass.',\n      '- Do not convert to long loose hair even if the pose suggests motion.'\n    ].join('\\n');\n  }\n\n  // Pose-specific prop rules\n  let allowedPropsBlock = '';\n  if (allowedProps.length) {\n    allowedPropsBlock = [\n      'ALLOWED PROPS (THIS POSE ONLY):',\n      ...allowedProps.map(p => {\n        if (p.toLowerCase() === 'sandwich') {\n          return [\n            '- Sandwich: simple, unbranded wedge on light-brown bread.',\n            '- Held naturally in the hands near the mouth; may be partially bitten.',\n            '- Keep prop small; do not occlude the hair silhouette.',\n            '- No crumbs, no sauce drips, no logos or text.'\n          ].join('\\n');\n        }\n        // generic rule for any other future prop\n        return `- ${p}: simple, unbranded, minimal detail, does not occlude face or hair silhouette.`;\n      })\n    ].join('\\n');\n  }\n\n  const traitLines = [\n    `Hair: ${cs.hairColor || 'N/A'} ${cs.hairStyle || 'N/A'}`,\n    `Skin: ${cs.skinTone || 'N/A'}`,\n    `Clothing: ${cs.clothingStyle || 'N/A'}`,\n    `Age: ${cs.age ?? 'N/A'} years`\n  ].join('\\n');\n\n  const poseText = USE_POSE_GRAMMAR && POSE_TEXT[String(poseNum)]\n    ? `POSE DESCRIPTION (B): ${POSE_TEXT[String(poseNum)]}`\n    : '';\n\n  const promptText = [\n    'ULTRA-CRITICAL INSTRUCTION:',\n    'Generate EXACTLY ONE image combining:',\n    '- IMAGE A (appearance source of truth)',\n    '- IMAGE B (pose only)\\n',\n    'MANDATORY APPEARANCE TRAITS (from IMAGE A - DO NOT CHANGE):',\n    traitLines,\n    '',\n    positivesBlock,\n    negativesBlock,\n    hairstyleLock ? '\\n' + hairstyleLock : '',\n    allowedPropsBlock ? '\\n' + allowedPropsBlock : '',\n    '',\n    'FINAL RULES:',\n    '- Do not modify hair silhouette.',\n    '- Do not modify facial features.',\n    '- Do not modify clothing colors or logos.'\n  ].concat(poseText ? ['\\n', poseText] : []).join('\\n');\n\n  const parts = [\n    { text: 'IMAGE A – CHARACTER REFERENCE (appearance source of truth):' },\n    { inlineData: { mimeType: 'image/png', data: characterBase64 } },\n    { text: 'IMAGE B – POSE REFERENCE (body position ONLY; ignore appearance):' },\n    { inlineData: { mimeType: 'image/png', data: poseBase64 } },\n    { text: promptText }\n  ];\n\n  const requestBody = {\n    systemInstruction: { role: 'system', parts: [{ text: systemText }] },\n    contents: [{ role: 'user', parts }],\n    generationConfig,\n  };\n\n  // Push updated item (keep derived pose for downstream keys/filenames)\n  results.push({\n    json: {\n      ...j,\n      poseNumber: poseNum,\n      currentPoseNumber: poseNum,\n      index: poseNum - 1,            // optional helper\n      correlationId,                 // keep on item only\n      generationConfig,\n      requestBody,\n    }\n  });\n}\n\nreturn results;\n"
      },
      "id": "679cae54-a30e-4e12-8f96-6cbe6f782731",
      "name": "Prepare Gemini Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3136,
        7600
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Client-Request-Id",
              "value": "={{$json.correlationId}}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "id": "cea1a091-5f0a-4b11-89fb-ef5e10218d9e",
      "name": "Generate Character in Pose",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2960,
        7408
      ],
      "credentials": {
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract Generated Image — lightweight, single-input (merged response + context)\n// Keeps only essential context to avoid duplicating huge base64 strings from requestBody.\n\nconst merged = $input.first()?.json || {};\n\n// ---- pick only the small context you need downstream ----\nconst ctx = {\n  // pose + indexing\n  poseNumber: merged.poseNumber ?? merged.currentPoseNumber ?? merged.__meta?.poseNumber ?? null,\n  currentPoseNumber: merged.currentPoseNumber ?? merged.poseNumber ?? null,\n  index: merged.index ?? null,\n\n  // ids/meta\n  correlationId: merged.correlationId ?? null,\n  characterHash: merged.characterHash ?? null,\n  characterPath: merged.characterPath ?? null,\n  __meta: merged.__meta || {},\n\n  // order info you actually use later (optional)\n  amazonOrderId: merged.amazonOrderId ?? merged.orderData?.amazonOrderId ?? null,\n  orderData: merged.orderData ? {\n    amazonOrderId: merged.orderData.amazonOrderId ?? null,\n    publicR2Url: merged.orderData.publicR2Url ?? merged.publicR2Url ?? null,\n    r2BucketName: merged.orderData.r2BucketName ?? 'little-hero-assets'\n  } : undefined,\n\n  // specs needed for summary/debug (safe, small)\n  characterSpecs: merged.characterSpecs ?? undefined,\n  characterHashSpec: merged.characterHashSpec ?? undefined,\n  bookSpecs: merged.bookSpecs ?? undefined,\n};\n\n// minimal diag (no giant copies)\nctx._extractDiag = {\n  hasCandidatesTop: Array.isArray(merged.candidates),\n  hasCandidatesBody: !!(merged.body && Array.isArray(merged.body.candidates)),\n  poseHint: ctx.poseNumber,\n};\n\nlet body;\n// Normalize API response shape without copying big blobs\nif (Array.isArray(merged.candidates)) {\n  body = merged;\n} else if (merged.body && Array.isArray(merged.body.candidates)) {\n  body = merged.body;\n} else {\n  return [{ json: { ...ctx, extractionSuccess: false, _STATUS: 'FAILED', extractionError: 'No candidates object found' } }];\n}\n\nconst candidates = body.candidates;\nif (!Array.isArray(candidates) || candidates.length === 0) {\n  return [{ json: { ...ctx, extractionSuccess: false, _STATUS: 'FAILED', extractionError: 'No candidates found' } }];\n}\n\nconst cand = candidates[0];\nif (cand.finishReason && cand.finishReason !== 'STOP') {\n  return [{ json: { ...ctx, extractionSuccess: false, _STATUS: 'FAILED', extractionError: `finishReason=${cand.finishReason}` } }];\n}\n\nconst parts = cand.content?.parts || [];\nif (!Array.isArray(parts) || parts.length === 0) {\n  return [{ json: { ...ctx, extractionSuccess: false, _STATUS: 'FAILED', extractionError: 'No content parts' } }];\n}\n\nconst imagePart = parts.find(p => p?.inlineData?.data);\nif (!imagePart?.inlineData?.data || imagePart.inlineData.data.length < 100) {\n  return [{ json: { ...ctx, extractionSuccess: false, _STATUS: 'FAILED', extractionError: 'No valid image data' } }];\n}\n\n// ✅ success (small payload out)\nreturn [{\n  json: {\n    ...ctx,\n    extractionSuccess: true,\n    _STATUS: 'IMAGE_FOUND',\n    extractedImageData: imagePart.inlineData.data,\n  }\n}];\n"
      },
      "id": "6ee48d6f-35d8-4a68-9fe4-be9b24edfcfe",
      "name": "Extract Generated Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2592,
        7408
      ]
    },
    {
      "parameters": {
        "jsCode": "// Diagnostic: Check what fields we actually have\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  const diagnostic = {\n    itemIndex: i,\n    allKeys: Object.keys(item.json),\n    hasCharacterPath: !!item.json.characterPath,\n    hasCharacterHash: !!item.json.characterHash,\n    hasCurrentPoseNumber: !!item.json.currentPoseNumber,\n    hasCharacterSpecs: !!item.json.characterSpecs,\n    characterPath: item.json.characterPath,\n    characterHash: item.json.characterHash,\n    currentPoseNumber: item.json.currentPoseNumber\n  };\n  \n  results.push({\n    json: {\n      ...item.json,\n      _DIAGNOSTIC: diagnostic\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "061c3fbc-0b4b-4591-ba3a-4bdedfe3c757",
      "name": "DIAGNOSTIC: Check Fields",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3616,
        7664
      ],
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json._STATUS }}",
              "value2": "IMAGE_FOUND"
            }
          ]
        }
      },
      "id": "547aec62-f21f-4ca7-b999-f78f2c5404ec",
      "name": "Filter: Only Items With Images",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -2416,
        7408
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Client-Request-Id",
              "value": "={{$json.correlationId}}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -5792,
        7392
      ],
      "id": "465d75d9-78dc-42ae-856a-b2190340f115",
      "name": "Generate Custom Base Character",
      "credentials": {
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract first image from Gemini response and output as n8n binary\nconst input = $input.first();\nconst res = input.json;\n\nconst parts = res?.candidates?.[0]?.content?.parts ?? [];\nconst imagePart = parts.find(p => p?.inlineData?.data);\n\nif (!imagePart?.inlineData?.data) {\n  throw new Error('No inlineData image found in Gemini response');\n}\n\nconst mime = imagePart.inlineData.mimeType || 'image/png';\nconst buf = Buffer.from(imagePart.inlineData.data, 'base64');\n\nconst binary = await this.helpers.prepareBinaryData(buf, 'generated.png', mime);\n\nconst originalOrderData = $('Generate Character Hash').first().json;\n\nreturn [{\n  json: {\n    ...originalOrderData,\n    generatedImage: { mimeType: mime, size: buf.length }\n  },\n  binary: { data: binary }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5568,
        7392
      ],
      "id": "719e8f60-a9f1-4fa2-8853-4f850b51de7d",
      "name": "Process Gemini API response and extract generated image"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Gemini API request for CUSTOM BASE CHARACTER (BG-removal optimized)\n// v2: Accepts binary OR base64-in-JSON. Clear errors, keeps hairPromptBlock.\n// NOTE: Do NOT include correlationId in the POST body; keep it on the item only.\n\nconst item = $input.first();\nconst j = item.json || {};\nconst cs = j.characterSpecs || {};\n\n// ---------- 1) Find an image source: binary first, then JSON base64 ----------\nconst bin = item.binary || {};\nconst binKeys = Object.keys(bin);\n\n// Preferred binary keys (use first that exists)\nconst preferred = ['data', 'image', 'file', 'character', 'reference'];\n\nlet base64Image = null;\nlet mimeType = 'image/png';\nlet base64Source = '';\n\nif (binKeys.length) {\n  // Use binary → buffer → base64\n  const binaryKey = preferred.find(k => binKeys.includes(k)) || binKeys[0];\n  try {\n    const buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\n    base64Image = buffer.toString('base64');\n    mimeType = (bin[binaryKey] && bin[binaryKey].mimeType) || mimeType;\n    base64Source = `binary:${binaryKey}`;\n  } catch (e) {\n    throw new Error(`Prepare Binary: Failed to read binary buffer. Keys present: ${binKeys.join(', ')}. Root: ${e.message}`);\n  }\n} else {\n  // Try known JSON base64 fields (strip data URI if present)\n  const candidates = [\n    'extractedImageData',\n    'referenceImageBase64',\n    'poseBase64',\n    'characterBase64',\n    'imageBase64',\n    'base64',\n  ];\n\n  for (const key of candidates) {\n    let v = j[key];\n    if (typeof v === 'string' && v.length > 100) {\n      const m = v.match(/^data:(image\\/[a-z0-9+.\\-]+);base64,(.*)$/i);\n      if (m) {\n        mimeType = m[1];\n        v = m[2];\n      }\n      base64Image = v;\n      base64Source = `json:${key}`;\n      break;\n    }\n  }\n}\n\n// If still nothing, explain exactly what to provide\nif (!base64Image || base64Image.length < 100) {\n  throw new Error(\n    'Prepare Binary: No image found. Provide one of: item.binary.[data|image|file|character|reference] ' +\n    'OR JSON base64 in one of [extractedImageData, referenceImageBase64, poseBase64, characterBase64, imageBase64, base64].'\n  );\n}\n\n// ---------- 2) Core fields ----------\nconst characterHash = j.characterHash || cs.hash || 'nohash';\nconst correlationId = `${characterHash}-BASE-${Date.now()}`; // NOT sent\n\n// ---------- 3) Optional upstream dynamic text and hair block ----------\nconst upstreamText = (j.basePromptText || '').trim();\nconst hairBlock = (j.hairPromptBlock || '').trim();\nconst hairMeta = j.hairPromptMeta || {};\n\n// Canonical-aware hairstyle lock (example for ponytail)\nlet hairstyleLock = '';\nif (hairMeta.styleKey === 'ponytail') {\n  hairstyleLock = [\n    'HAIRSTYLE LOCK — PONYTAIL:',\n    '- Hair is tied back in a single ponytail; a visible tie gathers the hair.',\n    '- No loose/free-flowing hair around face, shoulders, or back.',\n    '- Ponytail tail sits behind head/neck; silhouette is one connected mass.',\n    '- Do not convert to loose hair even if the pose implies motion.',\n  ].join('\\n');\n}\n\n// ---------- 4) Fallback prompt if no upstream text provided ----------\nconst fallbackText = [\n  'TRAIT MANIFEST:',\n  `- Skin tone: ${cs.skinTone || 'N/A'}`,\n  `- Hair: ${cs.hairColor || 'N/A'} ${cs.hairStyle || 'N/A'}`,\n  `- Clothing style: ${cs.clothingStyle || 'N/A'}`,\n  `- Favorite color: ${cs.favoriteColor || 'N/A'}`,\n  `- Age-appropriate for ${cs.age ?? 'N/A'} years old`,\n  '',\n  'POSITIVES — DO THIS:',\n  '- Match the storybook watercolor style of the reference.',\n  '- Use the TRAIT MANIFEST exactly (face, hair, skin, clothing).',\n  '- Render hair as a single, opaque silhouette (no gaps).',\n  '',\n  'NEGATIVES — DO NOT DO THIS:',\n  '- Do NOT add props, logos, text, or background elements.',\n  '- Do NOT change hair silhouette or facial proportions.',\n  '- Do NOT use semi-transparent hair strokes, wisps, halos, or outer glows.',\n  hairstyleLock ? '\\n' + hairstyleLock : '',\n  '',\n  'BACKGROUND: Pure white (#FFFFFF). NO transparency.',\n  'OUTPUT: Exactly ONE image matching the reference pose.',\n].join('\\n');\n\nconst usedFallback = !upstreamText;\n\n// ---------- 5) Build user text ----------\nconst userParts = [];\nif (hairBlock) userParts.push(hairBlock);\nif (usedFallback) {\n  userParts.push(fallbackText);\n} else {\n  userParts.push(upstreamText);\n  if (hairstyleLock) userParts.push(hairstyleLock);\n}\nconst userText = userParts.join('\\n\\n');\n\n// ---------- 6) System instruction ----------\nconst systemText = [\n  'You are a precise illustration tool.',\n  'CRITICAL: Preserve EXACT requested traits. Use the reference image only as a style guide.',\n  'HAIR OUTPUT POLICY:',\n  '- Hair must render as a SINGLE, OPAQUE MASS (one connected shape).',\n  '- No gaps, holes, or see-through spaces between strands.',\n  '- No wispy flyaway hairs, single-hair lines, or motion blur.',\n  '- Edges must be clean and closed (anti-aliased OK), with NO interior pinholes.',\n  '- Do NOT add halos, outer glows, outlines, or transparency on hair.',\n].join('\\n');\n\n// ---------- 7) Generation config ----------\nconst generationConfig = {\n  imageConfig: { aspectRatio: '1:1' },\n  temperature: 0.3,\n};\n\n// ---------- 8) Build request body (no correlationId inside) ----------\nconst requestBody = {\n  systemInstruction: { role: 'system', parts: [{ text: systemText }] },\n  contents: [{\n    parts: [\n      { text: userText },\n      { inlineData: { mimeType, data: base64Image } },\n    ],\n  }],\n  generationConfig,\n};\n\n// ---------- 9) Output ----------\nreturn [{\n  json: {\n    ...j,\n    correlationId,\n    generationConfig,\n    requestBody,\n    _debug: {\n      base64Source,\n      mimeType,\n      binaryKeysPresent: binKeys,\n    },\n  },\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6848,
        7024
      ],
      "id": "9f24fe7e-92a0-4626-9c4c-8c22f20586f0",
      "name": "Prepare binary"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.characterPath }}/base-character.png",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -5344,
        7392
      ],
      "id": "04585391-3e27-4bcf-a22f-b99557f47e00",
      "name": "Upload a file",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Just pass through all items - minimal validation\nconst items = $input.all();\n\nconsole.log(`Received ${items.length} items for Bria AI submission`);\n\nif (items.length > 0) {\n  console.log('Sample item fields:', Object.keys(items[0].json));\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  if (!item.json.extractedImageData) {\n    throw new Error(`Item ${i} missing extractedImageData`);\n  }\n}\n\nreturn items;"
      },
      "id": "aea90537-bde5-46e3-a830-4119904a2592",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2176,
        7408
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://engine.prod.bria-api.com/v2/image/edit/remove_background",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api_token",
              "value": "eb0fed5156c441148c462a74d3f92f00"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{$json.briaPayload}}",
        "options": {}
      },
      "id": "bacceb9d-8123-47da-b8fb-f916613421eb",
      "name": "Submit to Bria AI",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        512,
        7552
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Store Submission Result - Extract from Bria response + metadata (robust hash + pose + path)\n// Consolidates a Bria API response with local metadata, preferring trusted upstream data.\n\n// --- Constants (keep in sync across nodes)\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_R2  = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\n\n// --- Gather inputs\nconst inputs = $input.all();\n\n// --- Utilities\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// --- Upstream order snapshot (Generate Character Hash)\nconst gen = $('Generate Character Hash').first()?.json || {};\n\n// --- Identify response & meta items\nconst respItem = inputs.find(i => {\n  const j = i.json || {};\n  return j.request_id || j.status_url || j.data?.request_id || j.result?.request_id || j.links?.status;\n}) || inputs[0];\n\nconst resp = respItem?.json || {};\n\nconst metaItem = inputs.find(i => (i.json && i.json.__meta)) || inputs[0];\nconst meta = (metaItem?.json && metaItem.json.__meta) ? metaItem.json.__meta : {};\n\n// --- Hash sources (prefer Capture Lean Meta → Generate Character Hash)\nconst metaNodeHash = $('Capture Lean Meta').first()?.json?.__meta?.characterHash;\nconst genNodeHash  = gen.characterHash;\nconst upstreamHash = !isBadHash(metaNodeHash) ? metaNodeHash\n                   : (!isBadHash(genNodeHash) ? genNodeHash\n                   : null);\n\n// --- Bria response ids\nconst requestId =\n  resp.request_id ?? resp.requestId ??\n  resp.data?.request_id ?? resp.result?.request_id ?? null;\n\nconst statusUrl =\n  resp.status_url ?? resp.statusUrl ??\n  resp.data?.status_url ?? resp.result?.status_url ??\n  resp.links?.status ?? null;\n\nconst failed = !(requestId && statusUrl);\n\n// --- Pose (clamp 1–12)\nconst rawPose =\n  meta.poseNumber ??\n  metaItem?.json?.poseNumber ??\n  metaItem?.json?.currentPoseNumber ??\n  respItem?.json?.poseNumber ??\n  respItem?.json?.currentPoseNumber ??\n  1;\n\nconst poseParsed = Number.isFinite(Number(rawPose)) ? Number(rawPose) : 1;\nconst poseNumber = Math.min(12, Math.max(1, poseParsed));\n\n// --- Resolve characterHash (trusted upstream → local)\nconst localHash =\n  meta.characterHash ??\n  metaItem?.json?.characterHash ??\n  respItem?.json?.characterHash ??\n  null;\n\nconst characterHash = !isBadHash(localHash) ? localHash\n                    : (!isBadHash(upstreamHash) ? upstreamHash\n                    : null);\n\n// --- Path (best-effort) + backfill\nlet characterPath =\n  meta.characterPath ??\n  metaItem?.json?.characterPath ??\n  respItem?.json?.characterPath ??\n  metaItem?.json?.originalImageUrl ??\n  respItem?.json?.originalImageUrl ??\n  metaItem?.json?.imageUrl ??\n  respItem?.json?.imageUrl ??\n  metaItem?.json?.sourceUrl ??\n  respItem?.json?.sourceUrl ??\n  null;\n\nif (!characterPath && characterHash) {\n  characterPath = `${BASE_PREFIX}/${characterHash}/`;\n  console.log(`Backfilled characterPath=${characterPath}`);\n}\n\n// --- Pull rich order info from Generate Character Hash (with local overrides)\nconst amazonOrderId     = metaItem?.json?.amazonOrderId     ?? gen.amazonOrderId     ?? metaItem?.json?.orderData?.amazonOrderId ?? null;\nconst characterSpecs    = metaItem?.json?.characterSpecs    ?? gen.characterSpecs    ?? {};\nconst characterHashSpec = metaItem?.json?.characterHashSpec ?? gen.characterHashSpec ?? {};\nconst bookSpecs         = metaItem?.json?.bookSpecs         ?? gen.bookSpecs         ?? {};\nconst orderDetails      = metaItem?.json?.orderDetails      ?? gen.orderDetails      ?? {};\nconst publicR2Url       = metaItem?.json?.publicR2Url       ?? gen.publicR2Url       ?? DEFAULT_R2;\nconst templatePath      = metaItem?.json?.templatePath      ?? gen.templatePath      ?? 'templates';\n\n// --- Logs\nconsole.log(\n  `Stored: pose=${poseNumber}, requestId=${requestId ? requestId.substring(0,8) : 'null'}..., failed=${failed}`\n);\nconsole.log(`[LOCAL] characterHash=${characterHash || 'null'} path=${characterPath || 'null'} orderId=${amazonOrderId || 'null'}`);\n\n// --- Output (now includes full order info)\nconst out = {\n  requestId,\n  statusUrl,\n  poseNumber,\n  characterHash,\n  characterPath,\n  amazonOrderId,\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  templatePath,\n  failed,\n  submittedAt: new Date().toISOString(),\n};\n\nreturn [{ json: out }];\n"
      },
      "id": "e9ef1edf-8ce6-47fa-8425-75ddedc8282a",
      "name": "Store Submission Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1264,
        7440
      ]
    },
    {
      "parameters": {
        "amount": 6,
        "unit": "seconds"
      },
      "id": "4d7ba636-74b9-4340-8e96-d7898d4fab5a",
      "name": "Wait 6 Seconds",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        1552,
        7664
      ],
      "webhookId": "f0a55f7b-ff1e-4c89-b829-1906983d5853",
      "notes": "Rate limiting: 10 req/min = 1 req/6 sec"
    },
    {
      "parameters": {
        "jsCode": "// === CREATE FINAL SUMMARY (robust hash + order propagation + trace fields) ===\n\nconst incomingItems = $input.all();\nconsole.log('=== CREATE FINAL SUMMARY ===');\nconsole.log(`Received ${incomingItems.length} items from loop`);\n\nconst isBadHash = (h) => !h || h === 'nohash' || h === 'unknown' || typeof h !== 'string' || h.length < 4;\n\n// Upstream nodes\nconst metaHash = $('Capture Lean Meta').first()?.json?.__meta?.characterHash;\nconst genNode  = $('Generate Character Hash').first()?.json || {};\nconst genHash  = genNode?.characterHash;\nconst upstreamHash = !isBadHash(metaHash) ? metaHash : (!isBadHash(genHash) ? genHash : null);\n\n// Prefer upstream order snapshot, fall back sensibly\nconst firstItem   = incomingItems[0]?.json || {};\nconst sourceOrder = Object.keys(genNode).length ? genNode : firstItem;\n\n// IDs\nconst amazonOrderId =\n  genNode?.amazonOrderId ??\n  sourceOrder?.amazonOrderId ??\n  firstItem?.orderData?.amazonOrderId ??\n  firstItem?.amazonOrderId ??\n  null;\n\n// Rich fields (prefer Generate Character Hash)\nconst characterSpecs    = sourceOrder.characterSpecs    ?? {};\nconst characterHashSpec = sourceOrder.characterHashSpec ?? {};\nconst bookSpecs         = sourceOrder.bookSpecs         ?? {};\nconst orderDetails      = sourceOrder.orderDetails      ?? {};\nconst publicR2Url       = sourceOrder.publicR2Url       ?? firstItem?.publicR2Url ?? 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\nconst templatePath      = sourceOrder.templatePath      ?? firstItem?.templatePath ?? 'templates';\n\nconst orderData = {\n  amazonOrderId,\n  characterHash: upstreamHash || (!isBadHash(sourceOrder.characterHash) ? sourceOrder.characterHash : null),\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  templatePath,\n  r2BucketName: 'little-hero-assets'\n};\n\nconsole.log('Order data snapshot:', {\n  amazonOrderId: orderData.amazonOrderId || 'null',\n  characterHash: orderData.characterHash || 'null',\n  childName: orderData.characterSpecs?.childName || 'null'\n});\n\n// Build normalized submissions array with trace fields\nconst submissions = incomingItems.map((item, idx) => {\n  const j = item.json || {};\n  const pose =\n    j.__meta?.poseNumber ??\n    j.poseNumber ??\n    (Number.isFinite(Number(j.currentPoseNumber)) ? Number(j.currentPoseNumber) : (idx + 1));\n\n  // Hash\n  const chosenHash = !isBadHash(j.characterHash) ? j.characterHash\n                    : (!isBadHash(orderData.characterHash) ? orderData.characterHash\n                    : upstreamHash);\n\n  // Paths / URLs\n  const storageKey = j.__meta?.storageKey || j.r2Path || null;\n  const fileUrl =\n    j.fileUrl || j.imageUrl || j.sourceUrl ||\n    (publicR2Url && storageKey ? `${publicR2Url.replace(/\\/$/, '')}/${String(storageKey).replace(/^\\/+/, '')}` : null);\n\n  return {\n    poseNumber: pose,\n    characterHash: chosenHash || null,\n\n    // Trace\n    correlationId: j.correlationId || null,\n    generationConfig: j.generationConfig || null,\n\n    // Locations\n    storageKey,\n    r2Path: j.r2Path || storageKey || null,\n    fileUrl,\n\n    // Bria\n    briaSource: j.__meta?.briaSource || (fileUrl ? 'url' : (j.extractedImageData ? 'base64' : null)),\n    briaStatus: j.briaStatus || j.briaResult?.status || null,\n    briaRequestId: j.requestId || j.briaResult?.requestId || null,\n    briaStatusUrl: j.statusUrl || j.briaResult?.statusUrl || null,\n\n    // Failure / timing\n    failed: !!j.failed,\n    submittedAt: j.submittedAt || new Date().toISOString(),\n\n    // Order context\n    amazonOrderId: orderData.amazonOrderId || null,\n  };\n});\n\nconst valid = submissions.filter(s => s.briaRequestId && s.briaStatusUrl);\nconst failed = submissions.length - valid.length;\n\nconsole.log(`Valid submissions: ${valid.length}`);\nconsole.log(`Failed submissions: ${failed}`);\nconsole.log(`Pose numbers: ${submissions.map(s => s.poseNumber).join(', ')}`);\n\nif (!orderData.amazonOrderId) {\n  console.warn('⚠️ amazonOrderId is missing. Ensure Generate Character Hash receives/forwards it.');\n}\n\nreturn [{\n  json: {\n    totalSubmissions: submissions.length,\n    successful: valid.length,\n    failed: failed,\n    submittedAt: new Date().toISOString(),\n\n    submissions,\n    orderData,           // ← CRITICAL for 2B/next workflow\n    workflow2AComplete: true\n  }\n}];\n"
      },
      "id": "f86d65a5-5261-4842-bbeb-a8028982c7d1",
      "name": "Create Final Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3040,
        7120
      ]
    },
    {
      "parameters": {
        "amount": 90,
        "unit": "seconds"
      },
      "id": "89139a8c-46ab-4d38-a258-d994e65a5729",
      "name": "Wait 90 Seconds",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        -2848,
        7120
      ],
      "webhookId": "1edb1710-aa27-4854-9510-76b95a4bcef5",
      "notes": "Give Bria AI time to process images"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://thepeakbeyond.app.n8n.cloud/webhook/bg-removal",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json }}",
        "options": {}
      },
      "id": "39c3fb70-3ef0-45fe-9241-29392a65f4e0",
      "name": "Trigger Workflow B",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2688,
        7120
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "const j = $input.first().json;\ndelete j.extractedImageData;\ndelete j.poseBase64;\ndelete j.characterBase64;\ndelete j.requestBody;\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        7552
      ],
      "id": "9a0ceee4-cab8-4dfa-b593-af1c198c134c",
      "name": "Drop Heavy Fields"
    },
    {
      "parameters": {
        "jsCode": "// Capture Lean Meta — robust, unique R2 key per pose (prevents overwrites)\nconst src = ($input.first()?.json) || {};\n\n// --- Constants (keep in sync across nodes)\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_R2  = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\n\n// --- Utilities\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// --- Upstream order snapshot (Generate Character Hash)\nconst gen = $('Generate Character Hash').first()?.json || {};\n\n// 1) Pose number: try multiple sources, ensure 1–12 range, zero-pad for filenames\nconst poseNumberRaw =\n  src.poseNumber ??\n  src.currentPoseNumber ??\n  src.__meta?.poseNumber ??\n  null;\n\nif (!Number.isFinite(Number(poseNumberRaw))) {\n  throw new Error('Capture Lean Meta: poseNumber missing; ensure Stamp Pose Index runs before this node.');\n}\n\n\nconst poseParsed = Number.isFinite(Number(poseNumberRaw)) ? Number(poseNumberRaw) : 1;\nconst poseNumber = Math.min(12, Math.max(1, poseParsed));\nif (poseNumber !== poseParsed) {\n  console.warn(`Pose number ${poseParsed} out of range, clamped to ${poseNumber}`);\n}\nconst posePadded = String(poseNumber).padStart(2, '0');\n\n// 2) Character hash (prefer upstream; avoid placeholders)\nconst upstreamHash = gen.characterHash;\nconst resolvedHash =\n  src.characterHash ||\n  src.characterSpecs?.hash ||\n  upstreamHash ||\n  null;\nconst characterHash = isBadHash(resolvedHash) ? null : resolvedHash;\n\n// 3) Build storage key (unique per pose). If no hash, segregate by order + run.\nconst orderId  = src.amazonOrderId ?? gen.amazonOrderId ?? src.orderData?.amazonOrderId ?? 'unknown-order';\nconst runStamp = new Date().toISOString().replace(/[-:TZ.]/g,'').slice(0,14); // yyyymmddhhmmss\n\nlet storageKey;\nlet characterPath;\n\nif (characterHash) {\n  // Canonical per-character, per-pose key\n  const fileName = `characters_${characterHash}_pose${posePadded}.png`;\n  characterPath  = `${BASE_PREFIX}/${characterHash}/`; // folder-style (not URL)\n  storageKey     = `${characterPath}${fileName}`;\n} else {\n  // Fallback: keep files segregated so nothing overwrites\n  characterPath  = `${BASE_PREFIX}/_nohash/${orderId}/run_${runStamp}/`;\n  storageKey     = `${characterPath}pose${posePadded}.png`;\n}\n\n// 4) Pull rich order info from Generate Character Hash (with local override)\nconst amazonOrderId     = src.amazonOrderId     ?? gen.amazonOrderId     ?? src.orderData?.amazonOrderId ?? null;\nconst characterSpecs    = src.characterSpecs    ?? gen.characterSpecs    ?? {};\nconst characterHashSpec = src.characterHashSpec ?? gen.characterHashSpec ?? {};\nconst bookSpecs         = src.bookSpecs         ?? gen.bookSpecs         ?? {};\nconst orderDetails      = src.orderDetails      ?? gen.orderDetails      ?? {};\nconst publicR2Url       = src.publicR2Url       ?? gen.publicR2Url       ?? DEFAULT_R2;\nconst templatePath      = src.templatePath      ?? gen.templatePath      ?? 'templates';\n\n// 5) Store in top-level + orderData + __meta\nObject.assign(src, {\n  amazonOrderId,\n  characterHash,\n  characterPath,   // folder-like path (not full URL)\n  templatePath,\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n});\n\nsrc.orderData = {\n  ...(src.orderData || {}),\n  amazonOrderId,\n  characterHash,\n  characterPath,\n  templatePath,\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  r2BucketName: src.orderData?.r2BucketName ?? 'little-hero-assets',\n};\n\nsrc.__meta = {\n  ...(src.__meta || {}),\n  poseNumber,       // 1..12\n  characterHash,    // may be null if not resolvable\n  storageKey,       // ← used by Add Upload to R2 (unique per pose)\n  characterPath,    // stable folder-style path\n};\n\nconsole.log(`Captured meta: pose=${poseNumber}, key=${storageKey}, hash=${characterHash || 'null'}, orderId=${amazonOrderId || 'null'}`);\n\nreturn [{ json: src }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1760,
        7408
      ],
      "id": "d2eb342d-1ede-4967-b9f2-4a25b5288b8b",
      "name": "Capture Lean Meta"
    },
    {
      "parameters": {
        "jsCode": "// Ensure we have binary.image for R2 upload.\n// Priority: keep existing binary.image → convert base64 → download from URL.\n// If none available, set __skipUpload=true and pass the item through.\n\nconst j = $json;\n\n// 1) Already have a binary? keep it\nif ($binary?.image) {\n  return [{ json: j, binary: $binary }];\n}\n\n// 2) Try known base64 fields\nlet b64 = j.extractedImageData || j.poseBase64 || j.characterBase64 || null;\n\nif (typeof b64 === 'string' && b64.length > 10) {\n  // Strip data URI prefix if present\n  let mime = 'image/png';\n  const m = b64.match(/^data:(image\\/[a-z0-9+.\\-]+);base64,(.*)$/i);\n  if (m) {\n    mime = m[1];\n    b64 = m[2];\n  }\n  const buf = Buffer.from(b64, 'base64');\n  const bin = await this.helpers.prepareBinaryData(\n    buf,\n    `${j.__meta?.poseNumber ?? 0}.png`,\n    mime\n  );\n  return [{ json: j, binary: { image: bin } }];\n}\n\n// 3) Try to download from a URL we already have\nconst url =\n  j.__meta?.characterPath ||\n  j.originalImageUrl ||\n  j.imageUrl ||\n  j.sourceUrl ||\n  null;\n\nif (typeof url === 'string' && /^https?:\\/\\//i.test(url)) {\n  const res = await this.helpers.request({\n    method: 'GET',\n    url,\n    encoding: null, // Buffer\n    gzip: true,\n  });\n  const bin = await this.helpers.prepareBinaryData(\n    Buffer.from(res),\n    `${j.__meta?.poseNumber ?? 0}.png`\n  );\n  return [{ json: j, binary: { image: bin } }];\n}\n\n// 4) Nothing available → mark and pass through (do NOT throw)\nj.__skipUpload = true;\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1584,
        7408
      ],
      "id": "2da69e9e-fb20-4d16-af94-65b76c8e3b5c",
      "name": "Make Binary from Base64"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "={{ $json.__meta.storageKey }}",
        "binaryPropertyName": "image",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -992,
        7312
      ],
      "id": "3adcb078-62cb-4e05-ba49-a13ed9c4fe42",
      "name": "Add Upload to R2",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Set Meta Path (final)\nconst j = $json;\nconst storageKey = j.__meta?.storageKey || null;\nconst didUpload = j.__meta?.didUpload === true;\n\n// Use bucket root; no folder prefix unless you put it inside storageKey.\nconst PUBLIC_BASE = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\n\nfunction joinUrl(base, key) {\n  if (!base || !key) return null;\n  const b = base.replace(/\\/+$/, '');\n  const k = String(key).replace(/^\\/+/, '');\n  return `${b}/${k}`;\n}\n\nif (storageKey && (didUpload || j.__meta?.characterPath == null)) {\n  j.__meta.characterPath = joinUrl(PUBLIC_BASE, storageKey);\n}\n\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        7424
      ],
      "id": "2a999617-d706-41d7-bc05-658a82881a7d",
      "name": "Set Meta Path"
    },
    {
      "parameters": {
        "url": "={{$json.__meta.characterPath}}",
        "options": {
          "response": {
            "response": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        7424
      ],
      "id": "09f2a649-03b9-4999-8059-552781bc44a4",
      "name": "Check Image URL (200)",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const probe = $items('Check Image URL (200)', 0, 0)[0]?.json;\nconst had200 = probe?.statusCode === 200 || probe?.status === 200;\n\nconst url = $json.__meta?.characterPath || null;\nconst b64 = $json.extractedImageData || null;\n\nreturn [{\n  json: {\n    ...$json,\n    _imageForBria: (had200 && url) ? url : b64,\n    _imageIsUrl: !!(had200 && url),\n    _urlCheckOk: !!had200,\n  },\n  binary: $input.first().binary,\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        7424
      ],
      "id": "71e93992-1524-44fd-9cd5-032a24a95dc7",
      "name": "URL OK or fallback to base64"
    },
    {
      "parameters": {
        "jsCode": "// Build Bria Payload — URL preferred, base64 fallback, with meta + tracing\nconst j = $json;\n\n// Robust URL pick (prefer fileUrl that your upload step set)\nlet url = j.fileUrl || j.imageUrl || j.sourceUrl || null;\n\n// If no direct URL, try constructing from publicR2Url + storageKey\nif (!url) {\n  const pub = j.publicR2Url || j.orderData?.publicR2Url;\n  const key = j.__meta?.storageKey || j.r2Path || j.__meta?.characterPath || null;\n  if (pub && key) {\n    url = `${String(pub).replace(/\\/$/, '')}/${String(key).replace(/^\\/+/, '')}`;\n  }\n}\n\n// Base64 fallback\nlet b64 = j.extractedImageData || j.poseBase64 || j.characterBase64 || null;\nif (typeof b64 === 'string') {\n  const m = b64.match(/^data:(image\\/[a-z0-9+.\\-]+);base64,(.*)$/i);\n  if (m) b64 = m[2];\n  b64 = b64.trim();\n  if (b64.length < 12) b64 = null;\n}\n\n// Pose (numeric, for logging)\nconst poseNumber =\n  j.__meta?.poseNumber ??\n  j.poseNumber ??\n  (Number.isFinite(Number(j.currentPoseNumber)) ? Number(j.currentPoseNumber) : null);\n\nif (!url && !b64) {\n  j.__meta = j.__meta || {};\n  j.__meta.__skipBria = true;\n  j.__meta.__skipReason = 'No usable image (no URL and no base64 present)';\n  delete j.briaPayload;\n  return [{ json: j }];\n}\n\n// Build Bria payload (what you POST)\nconst briaPayload = {\n  image: url || b64,              // Bria accepts a URL string or a base64 string\n  // Add a client-side meta object for your own traceability (Bria ignores unknown fields)\n  meta: {\n    correlationId: j.correlationId || null,\n    pose: poseNumber,\n    characterHash: j.characterHash || j.characterSpecs?.hash || null,\n    source: url ? 'url' : 'base64'\n  }\n};\n\n// Local metadata for your pipeline\nj.__meta = j.__meta || {};\nj.__meta.briaReady = true;\nj.__meta.briaSource = url ? 'url' : 'base64';\nj.__meta.poseNumber = poseNumber;\n\n// Save payload for the Submit-to-Bria node\nj.briaPayload = briaPayload;\n\nconsole.log(`Pose ${poseNumber}: Bria payload ready, source=${j.__meta.briaSource}`);\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        7424
      ],
      "id": "f7bdfc39-0a4a-4b86-ac23-f9b3f74d4203",
      "name": "Build Bria Payload"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "39ba2fb9-75f8-42d5-b646-637dc74862b3",
              "leftValue": "={{ !$json.__skipUpload }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1344,
        7408
      ],
      "id": "a08d568b-8fb9-40c9-8063-03bf9d0f7d50",
      "name": "If (should upload?)"
    },
    {
      "parameters": {
        "jsCode": "// Clean Binary After Upload (Function Item)\n// Assumes previous node is \"Attach Upload Response\" (Merge by position)\n\nconst out = { ...$json };\n\n// Normalize poseNumber -> number\nlet pose = out.currentPoseNumber ?? out.poseNumber ?? ($itemIndex + 1);\nif (typeof pose === 'string') pose = Number(pose.trim());\npose = Number(pose);\nout.poseNumber = pose;\nout.currentPoseNumber = pose;\n\n// Normalize index\nout.index = Number(out.index ?? $itemIndex);\n\n// Mark upload flags\nout.__meta = out.__meta || {};\nout.__meta.didUpload = true;\nif (out.__meta.poseNumber == null) out.__meta.poseNumber = pose;\n\n// Carry upload success if present\nif (typeof out.success !== 'undefined') out.upload_success = out.success;\n\n// Drop heavy fields if any leaked in\ndelete out.extractedImageData;\ndelete out.poseBase64;\ndelete out.characterBase64;\ndelete out.requestBody;\n\n// IMPORTANT: do not return $binary to keep memory low\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        7424
      ],
      "id": "2034934b-5258-46ec-8b93-6ac875cfe1fb",
      "name": "Clean Binary After Upload"
    },
    {
      "parameters": {
        "jsCode": "// No Upload Pass-through (prefer current item; no upstream lookups)\n// Use ONLY the current $json. Re-derive pose/index ONLY if missing.\n// This prevents resetting to pose=1 when earlier nodes exist.\n\nfunction parsePoseFromUrl(u) {\n  if (!u) return null;\n  const s = String(u);\n  const m = s.match(/\\/(\\d+)\\.(?:png|jpg|jpeg|webp)$/i);\n  return m ? Number(m[1]) : null;\n}\n\nconst out = { ...($json || {}) };   // keep exactly what came in\n\n// Pose: keep if present; otherwise derive from storageKey/url; last resort from index or $itemIndex\nlet pose = Number(\n  out.poseNumber ??\n  out.currentPoseNumber ??\n  out.__meta?.poseNumber ??\n  parsePoseFromUrl(out.__meta?.storageKey) ??\n  parsePoseFromUrl(out.originalImageUrl) ??\n  parsePoseFromUrl(out.imageUrl)\n);\n\nif (!Number.isFinite(pose) || pose < 1) {\n  pose = Number.isFinite(Number(out.index)) ? Number(out.index) + 1 : ($itemIndex + 1);\n}\n\n// If you always have 12 poses, clamp; otherwise remove this clamp.\nif (pose > 12) pose = 12;\n\n// Index: keep if present; else derive from pose\nlet idx = Number(out.index);\nif (!Number.isFinite(idx) || idx < 0) idx = pose - 1;\n\n// Normalize fields\nout.poseNumber = pose;\nout.currentPoseNumber = pose;\nout.index = idx;\n\nout.__meta = { ...(out.__meta || {}) };\nout.__meta.poseNumber = pose;\n\n// Do NOT touch urls/hashes or $binary; just forward\nreturn [{ json: out, binary: $binary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -816,
        7424
      ],
      "id": "79d5ca70-1929-4047-b003-d86146d147d5",
      "name": "No Upload Pass-through"
    },
    {
      "parameters": {
        "jsCode": "// Stamp Pose Index — single-item, authoritative, no $itemIndex fallback\nconst inItem = $input.first();\nconst j = { ...(inItem.json || {}) };\n\nfunction asIntMaybe(v) {\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n}\nfunction parsePoseFromString(s) {\n  if (!s) return null;\n  const m = String(s).match(/(?:pose[_\\- ]?(\\d{1,2}))|[_\\-\\.](\\d{1,2})(?:\\D|$)|\\/(\\d{1,2})\\.png$/i);\n  return m ? asIntMaybe(m[1] || m[2] || m[3]) : null;\n}\n\n// 1) Prefer upstream values (set in Reorganize/Prepare/Extract)\nlet pose =\n  asIntMaybe(j.poseNumber) ??\n  asIntMaybe(j.currentPoseNumber) ??\n  asIntMaybe(j.__meta?.poseNumber);\n\n// 2) If still missing, derive from filenames / recorded indices\nif (pose == null) {\n  const candidates = [\n    j.poseRefName, j.poseRefFilename, j.poseRef, j.poseFileName,\n    j.__reorg?.poseFileName,        // from Reorganize Merged Data\n  ];\n  for (const c of candidates) {\n    const parsed = parsePoseFromString(c);\n    if (parsed != null) { pose = parsed; break; }\n  }\n  // last resort: explicit numeric index captured upstream (1..12)\n  if (pose == null && asIntMaybe(j.__reorg?.fromIndex) != null) {\n    pose = asIntMaybe(j.__reorg.fromIndex);\n  }\n}\n\n// 3) Hard-fail if we still can't determine pose (prevents overwrites)\nif (pose == null || pose < 1 || pose > 12) {\n  throw new Error('Stamp Pose Index: poseNumber missing/invalid (expected 1..12).');\n}\n\n// 4) Clamp + write back (and mirror into __meta)\npose = Math.min(12, Math.max(1, pose));\nj.poseNumber = pose;\nj.currentPoseNumber = pose;\nj.index = pose - 1; // optional helper\nj.__meta = { ...(j.__meta || {}), poseNumber: pose };\n\nconsole.log(`Stamp Pose Index → pose=${pose}`);\nreturn [{ json: j, binary: inItem.binary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1968,
        7408
      ],
      "id": "09fde62b-a2f2-46e6-9c23-4d630355943c",
      "name": "Stamp Pose Index"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -832,
        7184
      ],
      "id": "657c5c79-c63f-4ba2-a375-d8e8438d0012",
      "name": "Merge"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1088,
        7440
      ],
      "id": "6fcbab90-d5b9-444c-8589-1d52467a235f",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "// Build Stamp Pose Index-compatible items from small inputs + downloaded binary\n// Downstream expects: array of items where item.json has\n// poseNumber (1-based), currentPoseNumber (same), index (0-based),\n// and the Gemini-style `candidates[0].content.parts[0].inlineData` payload.\n\nconst items = $input.all();\n\nreturn items.map((item, idx) => {\n  const j = item.json ?? {};\n  const bin = item.binary ?? {};\n\n  // derive/normalize indices\n  const pose = Number.isFinite(Number(j.poseNumber)) ? Number(j.poseNumber) : (idx + 1);\n  const index = Number.isFinite(Number(j.index)) ? Number(j.index) : idx;\n\n  // n8n stores binary as base64 string at {binaryKey}.data\n  const b = bin.data;\n  if (!b?.data) {\n    throw new Error(\"Binary 'data' missing. Ensure HTTP Request returned a File with binary property 'data'.\");\n  }\n\n  const out = {\n    ...j,\n    poseNumber: pose,\n    currentPoseNumber: pose,\n    index,\n    candidates: [\n      {\n        content: {\n          parts: [\n            {\n              inlineData: {\n                mimeType: b.mimeType || \"image/png\",\n                data: b.data // base64 string\n              }\n            }\n          ]\n        }\n      }\n    ]\n  };\n\n  // Keep binary if you want (not necessary for most downstream nodes)\n  return { json: out, binary: item.binary };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5088,
        7136
      ],
      "id": "ac26db0b-df54-4650-8e67-413872e58a18",
      "name": "Build Stamp Pose Output (Sim)"
    },
    {
      "parameters": {
        "url": "={{$json.imageUrl}}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -5280,
        7136
      ],
      "id": "815cbae3-2034-4c01-bdb4-facdb39a647c",
      "name": "Download Image"
    },
    {
      "parameters": {
        "jsCode": "// Capture Lean Meta (Sim Safe)\n// Derives pose, hash, storageKey, and characterPath from the simulated item.\n// Propagates amazonOrderId + characterSpecs + bookSpecs + orderDetails + publicR2Url.\n\nconst src = ($input.first()?.json) || {};\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_AMZ_ID = 'TEST-ORDER-002';\n\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\n// ---- helpers ----\nfunction tryHashFromNode() {\n  try {\n    return $items('Generate Character Hash', 0, 0)?.[0]?.json?.characterHash ?? null;\n  } catch { return null; }\n}\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try { return new URL(u).pathname.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n  catch { return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n}\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, '');\n}\n\n// ---- 0) Amazon Order ID (propagate strongly) ----\nconst amazonOrderId =\n  src.orderData?.amazonOrderId ??\n  src.amazonOrderId ??\n  src.__meta?.amazonOrderId ??\n  DEFAULT_AMZ_ID;\n\n// ---- 1) Pose number (1..12) ----\nconst poseNumberRaw = src.poseNumber ?? src.currentPoseNumber ?? src.__meta?.poseNumber ?? ($itemIndex + 1);\nconst poseParsed = Number.isFinite(Number(poseNumberRaw)) ? Number(poseNumberRaw) : 1;\nconst poseNumber = Math.min(12, Math.max(1, Number(poseParsed)));\n\n// ---- 2) Hash ----\nconst upstreamHash   = tryHashFromNode();\nconst urlHash        = hashFromUrl(src.originalImageUrl || src.imageUrl);\nconst resolvedHash   = src.characterHash || src.characterSpecs?.hash || urlHash || upstreamHash || null;\nconst characterHash  = isBadHash(resolvedHash) ? null : resolvedHash;\n\n// ---- 3) Paths ----\nlet characterPath =\n  src.__meta?.characterPath ||\n  src.characterPath ||\n  folderFromUrl(src.originalImageUrl || src.imageUrl) ||\n  (characterHash ? `${BASE_PREFIX}/${characterHash}/` : null);\n\nconst storageKey = characterHash ? `${BASE_PREFIX}/${characterHash}/${poseNumber}.png` : null;\n\n// ---- 4) Gather extended fields ----\nconst characterSpecs    = src.characterSpecs ?? src.orderData?.characterSpecs ?? {};\nconst characterHashSpec = src.characterHashSpec ?? src.orderData?.characterHashSpec ?? {};\nconst bookSpecs         = src.bookSpecs ?? src.orderData?.bookSpecs ?? {};\nconst orderDetails      = src.orderDetails ?? src.orderData?.orderDetails ?? {};\nconst publicR2Url       = src.publicR2Url ?? src.orderData?.publicR2Url ?? 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\nconst templatePath      = src.templatePath ?? 'templates';\n\n// ---- 5) Write back ----\nsrc.amazonOrderId = amazonOrderId;\nsrc.characterHash = characterHash ?? src.characterHash ?? null;\nsrc.characterPath = characterPath ?? src.characterPath ?? null;\nsrc.templatePath  = templatePath;\n\nsrc.characterSpecs    = characterSpecs;\nsrc.characterHashSpec = characterHashSpec;\nsrc.bookSpecs         = bookSpecs;\nsrc.orderDetails      = orderDetails;\nsrc.publicR2Url       = publicR2Url;\n\nsrc.orderData = {\n  ...(src.orderData || {}),\n  amazonOrderId,\n  characterHash: src.characterHash,\n  characterPath: src.characterPath,\n  templatePath,\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  r2BucketName: src.orderData?.r2BucketName ?? 'little-hero-assets',\n};\n\nsrc.__meta = {\n  ...(src.__meta || {}),\n  amazonOrderId,\n  poseNumber,\n  characterHash: src.characterHash,\n  storageKey,\n  characterPath: src.characterPath\n};\n\nreturn [{ json: src }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2240,
        8192
      ],
      "id": "2402bf43-f8da-4cae-a8a6-a2df91055cab",
      "name": "FOR TESTING - Capture Lean Meta",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Store Submission Result (Sim Safe) — with raw file URL\n// Works without Bria/Generate Character Hash. Safe for simulated inputs.\n// Now also carries full order info (amazonOrderId, characterSpecs, etc.).\n\nconst BASE_PREFIX = 'book-mvp-simple-adventure/order-generated-assets/characters';\nconst DEFAULT_AMZ_ID = 'TEST-ORDER-002';\n\nconst inputs = $input.all();\n\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try { return new URL(u).pathname.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n  catch { return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n}\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, '');\n}\n\nfunction pickMetaItem()  { return inputs.find(i => i?.json?.__meta) || inputs[0]; }\nfunction pickRespItem()  {\n  return inputs.find(i => {\n    const j = i?.json || {};\n    return j.request_id || j.requestId || j.status_url || j.statusUrl ||\n           j.data?.request_id || j.result?.request_id || j.links?.status;\n  }) || inputs[0];\n}\n\nconst metaItem = pickMetaItem();\nconst respItem = pickRespItem();\nconst meta = metaItem?.json?.__meta || {};\nconst resp = respItem?.json || {};\n\n// --- Amazon Order ID ---\nconst amazonOrderId =\n  metaItem?.json?.orderData?.amazonOrderId ??\n  metaItem?.json?.amazonOrderId ??\n  meta?.amazonOrderId ??\n  DEFAULT_AMZ_ID;\n\n// --- Pose ---\nconst rawPose =\n  meta.poseNumber ??\n  metaItem?.json?.poseNumber ??\n  metaItem?.json?.currentPoseNumber ??\n  respItem?.json?.poseNumber ??\n  respItem?.json?.currentPoseNumber ??\n  1;\n\nconst poseParsed = Number.isFinite(Number(rawPose)) ? Number(rawPose) : 1;\nconst poseNumber = Math.min(12, Math.max(1, Number(poseParsed)));\n\n// --- Source URL ---\nconst simSourceUrl =\n  metaItem?.json?.originalImageUrl || metaItem?.json?.imageUrl ||\n  respItem?.json?.originalImageUrl || respItem?.json?.imageUrl || null;\n\n// --- Hash ---\nconst localHash =\n  meta.characterHash ??\n  metaItem?.json?.characterHash ??\n  respItem?.json?.characterHash ??\n  metaItem?.json?.characterSpecs?.hash ??\n  respItem?.json?.characterSpecs?.hash ??\n  hashFromUrl(simSourceUrl) ??\n  null;\n\nconst characterHash = isBadHash(localHash) ? null : localHash;\n\n// --- Path ---\nlet characterPath =\n  meta.characterPath ??\n  metaItem?.json?.characterPath ??\n  respItem?.json?.characterPath ??\n  folderFromUrl(simSourceUrl) ??\n  (characterHash ? `${BASE_PREFIX}/${characterHash}/` : null);\n\n// --- Bria IDs (sim fabricate if needed) ---\nlet requestId =\n  resp.request_id ?? resp.requestId ??\n  resp.data?.request_id ?? resp.result?.request_id ?? null;\n\nlet statusUrl =\n  resp.status_url ?? resp.statusUrl ??\n  resp.data?.status_url ?? resp.result?.status_url ??\n  resp.links?.status ?? null;\n\nif (!requestId) {\n  const hashForId = characterHash || 'sim';\n  requestId = `sim-${hashForId}-${poseNumber}`;\n}\nif (!statusUrl && simSourceUrl) statusUrl = simSourceUrl;\n\n// --- Extended fields (carry forward) ---\nconst characterSpecs    = metaItem?.json?.characterSpecs ?? metaItem?.json?.orderData?.characterSpecs ?? {};\nconst characterHashSpec = metaItem?.json?.characterHashSpec ?? metaItem?.json?.orderData?.characterHashSpec ?? {};\nconst bookSpecs         = metaItem?.json?.bookSpecs ?? metaItem?.json?.orderData?.bookSpecs ?? {};\nconst orderDetails      = metaItem?.json?.orderDetails ?? metaItem?.json?.orderData?.orderDetails ?? {};\nconst publicR2Url       = metaItem?.json?.publicR2Url ?? metaItem?.json?.orderData?.publicR2Url ?? 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\nconst templatePath      = metaItem?.json?.templatePath ?? 'templates';\n\nconst failed = !(requestId && (statusUrl || characterHash || characterPath));\n\nconst out = {\n  requestId,\n  statusUrl,\n  poseNumber,\n  characterHash,\n  characterPath,\n  imageUrl: simSourceUrl || null,\n  originalImageUrl: simSourceUrl || null,\n\n  // new: carry order info\n  amazonOrderId,\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  templatePath,\n\n  failed,\n  submittedAt: new Date().toISOString(),\n};\n\nconsole.log(`SimSafe store: pose=${poseNumber}, id=${requestId}, failed=${failed}, amazonOrderId=${amazonOrderId}`);\nreturn [{ json: out }];\n"
      },
      "id": "ca0c7394-d192-46ac-8d69-1b1b19ab5117",
      "name": "FOR TESTING - Store Submission Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -768,
        8224
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// === CREATE FINAL SUMMARY (TEST) — no cross-node references ===\n// Uses only the incoming items to build orderData and submissions.\n\nconst incomingItems = $input.all();\nconsole.log('=== CREATE FINAL SUMMARY (TEST) ===');\nconsole.log(`Received ${incomingItems.length} items from loop`);\n\nconst SIM_AMAZON_ORDER_ID = 'TEST-ORDER-LOCAL-001';\nconst SIM_PUBLIC_R2_URL   = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\n\nconst isBadHash = (h) =>\n  !h || typeof h !== 'string' || h === 'nohash' || h === 'unknown' || h.trim().length < 4;\n\nfunction hashFromUrl(u) {\n  if (!u) return null;\n  try { return new URL(u).pathname.match(/\\/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n  catch { return String(u).match(/characters\\/([^/]+)\\//i)?.[1] ?? null; }\n}\nfunction folderFromUrl(u) {\n  if (!u) return null;\n  const path = (() => {\n    try { return new URL(u).pathname.replace(/^\\/+/, ''); }\n    catch { return String(u).replace(/^https?:\\/\\/[^/]+\\//, ''); }\n  })();\n  return path.replace(/[^/]+$/, '');\n}\n\n// ---- Helpers from ONLY incoming items ----\nfunction chooseGlobalHash(items) {\n  for (const it of items) {\n    const j = it?.json || {};\n    const candidate =\n      j.characterHash ??\n      j.__meta?.characterHash ??\n      j.characterSpecs?.hash ??\n      hashFromUrl(j.originalImageUrl || j.imageUrl) ??\n      null;\n    if (!isBadHash(candidate)) return candidate;\n  }\n  return null;\n}\nfunction chooseAmazonOrderId(items) {\n  for (const it of items) {\n    const j = it?.json || {};\n    const id = j.orderData?.amazonOrderId ?? j.amazonOrderId ?? null;\n    if (id && String(id).trim().length > 0) return String(id).trim();\n  }\n  return SIM_AMAZON_ORDER_ID;\n}\n\n// Prefer any embedded order snapshot if present, else minimal structure\nconst firstJson   = incomingItems?.[0]?.json || {};\nconst globalHash  = chooseGlobalHash(incomingItems);\nconst amazonOrderId = chooseAmazonOrderId(incomingItems);\n\n// Pull extended fields if present\nconst characterSpecs    = firstJson.orderData?.characterSpecs ?? firstJson.characterSpecs ?? { childName: 'Sky', hometown: 'Seattle' };\nconst characterHashSpec = firstJson.orderData?.characterHashSpec ?? firstJson.characterHashSpec ?? {};\nconst bookSpecs         = firstJson.orderData?.bookSpecs ?? firstJson.bookSpecs ?? { title: 'Adventure Book', totalPages: 16, format: '8.5x8.5_softcover', bookType: 'animal-guide' };\nconst orderDetails      = firstJson.orderData?.orderDetails ?? firstJson.orderDetails ?? {};\nconst publicR2Url       = firstJson.orderData?.publicR2Url ?? firstJson.publicR2Url ?? SIM_PUBLIC_R2_URL;\n\nconst orderData = {\n  // IDs\n  amazonOrderId,\n  characterHash: !isBadHash(firstJson.orderData?.characterHash)\n                    ? firstJson.orderData.characterHash\n                    : (!isBadHash(firstJson.characterHash)\n                        ? firstJson.characterHash\n                        : globalHash),\n\n  // Rich fields\n  characterSpecs,\n  characterHashSpec,\n  bookSpecs,\n  orderDetails,\n  publicR2Url,\n  r2BucketName: firstJson.orderData?.r2BucketName ?? 'little-hero-assets'\n};\n\nconsole.log('Order data snapshot (TEST):', {\n  amazonOrderId: orderData.amazonOrderId,\n  characterHash: orderData.characterHash || 'null',\n  childName: orderData.characterSpecs?.childName || 'null'\n});\n\n// ---- Build normalized submissions array (prefer item hash; fallback to order hash)\nconst submissions = incomingItems.map((item, idx) => {\n  const j = item.json || {};\n\n  const pose =\n    Number(j.poseNumber) ||\n    Number(j.currentPoseNumber) ||\n    (idx + 1);\n\n  const itemHash =\n    j.characterHash ??\n    j.__meta?.characterHash ??\n    j.characterSpecs?.hash ??\n    hashFromUrl(j.originalImageUrl || j.imageUrl) ??\n    null;\n\n  const chosenHash = !isBadHash(itemHash)\n    ? itemHash\n    : (!isBadHash(orderData.characterHash) ? orderData.characterHash : null);\n\n  // characterPath: prefer explicit/meta; otherwise derive from the file URL\n  let path =\n    j.__meta?.characterPath ??\n    j.characterPath ??\n    j.sourceUrl ??\n    null;\n\n  if (!path) {\n    const rawUrl = j.originalImageUrl || j.imageUrl || null;\n    if (rawUrl) path = folderFromUrl(rawUrl);\n  }\n\n  const briaSubmissionSuccess = !!(j.requestId && j.statusUrl);\n  return {\n    requestId: j.requestId || null,\n    statusUrl: j.statusUrl || null,\n\n    // keep for compatibility/diagnostics\n    extractedImageData: j.extractedImageData || null,\n\n    // pose\n    currentPoseNumber: pose,\n    poseNumber: pose,\n\n    // id & pathing\n    characterHash: chosenHash || null,\n    characterPath: path || null,\n\n    // raw file references if present\n    imageUrl: j.imageUrl || null,\n    originalImageUrl: j.originalImageUrl || null,\n\n    // (optional) pass-through extended fields per image for debugging\n    amazonOrderId: j.amazonOrderId || orderData.amazonOrderId,\n\n    failed: !!j.failed,\n    submittedAt: j.submittedAt || new Date().toISOString(),\n    briaSubmissionSuccess\n  };\n});\n\nconst valid = submissions.filter(s => s.requestId && s.statusUrl);\nconst failed = submissions.length - valid.length;\n\nconsole.log(`Valid submissions: ${valid.length}`);\nconsole.log(`Failed submissions: ${failed}`);\nconsole.log(`Pose numbers: ${submissions.map(s => s.poseNumber).join(', ')}`);\n\nreturn [{\n  json: {\n    totalSubmissions: submissions.length,\n    successful: valid.length,\n    failed: failed,\n    submittedAt: new Date().toISOString(),\n\n    // CRITICAL for 2B/3 handoff\n    submissions,\n    orderData,\n    workflow2AComplete: true\n  }\n}];\n"
      },
      "id": "22f9ea9d-9c27-4ff4-ae58-00fe9d6c5fed",
      "name": "FOR TESTING - Create Final Summary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4288,
        6656
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Sim Image Indexes + hash for Capture Lean Meta\n// Mode: Run Once for All Items  |  Language: JavaScript\n\n// ---- EDIT THESE CONSTANTS ----\nconst CHARACTER_HASH = '1dde0fac84943088';\nconst PUBLIC_R2_URL  = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\nconst PUBLIC_BASE    = `${PUBLIC_R2_URL}/book-mvp-simple-adventure/order-generated-assets/characters`;\nconst AMAZON_ORDER_ID = 'TEST-ORDER-002';\n// Personalization defaults for sim runs\nconst SIM_CHARACTER_SPECS = {\n  childName: 'Alex',\n  hometown: 'Seattle',\n  pronouns: 'he/him',\n  age: 4,\n  favoriteColor: 'yellow',\n  animalGuide: 'unicorn',\n  clothingStyle: 't-shirt and shorts',\n};\n// Visual-gen traits (often used by upstream gen / audits)\nconst SIM_CHARACTER_HASH_SPEC = {\n  skinTone: 'medium',\n  hairColor: 'black',\n  hairStyle: 'medium/ponytail',\n  age: 4,\n  pronouns: 'he/him',\n  favoriteColor: 'yellow',\n  animalGuide: 'unicorn',\n  clothingStyle: 't-shirt and shorts',\n};\n// Book + order details\nconst SIM_BOOK_SPECS = {\n  title: 'Alex and the Adventure Compass',\n  totalPages: 16,\n  format: '8.5x8.5_softcover',\n  bookType: 'animal-guide',\n};\nconst SIM_ORDER_DETAILS = {\n  quantity: 1,\n  shippingAddress: {\n    name: 'Test Customer',\n    address: '123 Test Street',\n    city: 'Test City',\n    state: 'CA',\n    zip: '90210',\n  },\n};\n// --------------------------------\n\nconst COUNT = 12;\n\nreturn Array.from({ length: COUNT }, (_, i) => {\n  const poseNumber = i + 1;\n  const url = `${PUBLIC_BASE}/${CHARACTER_HASH}/${poseNumber}.png`;\n\n  return {\n    json: {\n      // indexing\n      poseNumber,         // 1..12\n      index: i,           // 0-based\n\n      // image URLs so preview/downstream still works\n      imageUrl: url,\n      originalImageUrl: url,\n\n      // identity\n      amazonOrderId: AMAZON_ORDER_ID,\n      characterHash: CHARACTER_HASH,\n      characterPath: `characters/${CHARACTER_HASH}`,\n      templatePath: 'templates',\n\n      // story personalization + visual-gen traits\n      characterSpecs: { ...SIM_CHARACTER_SPECS, hash: CHARACTER_HASH },\n      characterHashSpec: { ...SIM_CHARACTER_HASH_SPEC },\n\n      // book + order\n      bookSpecs: { ...SIM_BOOK_SPECS },\n      orderDetails: { ...SIM_ORDER_DETAILS },\n\n      // public base (for building final URLs later)\n      publicR2Url: PUBLIC_R2_URL,\n\n      // nested orderData for compatibility with older nodes\n      orderData: {\n        amazonOrderId: AMAZON_ORDER_ID,\n        characterHash: CHARACTER_HASH,\n        characterSpecs: { ...SIM_CHARACTER_SPECS },\n        characterHashSpec: { ...SIM_CHARACTER_HASH_SPEC },\n        bookSpecs: { ...SIM_BOOK_SPECS },\n        orderDetails: { ...SIM_ORDER_DETAILS },\n        r2BucketName: 'little-hero-assets',\n        publicR2Url: PUBLIC_R2_URL,\n      },\n\n      // meta\n      __meta: {\n        poseNumber,\n        amazonOrderId: AMAZON_ORDER_ID,\n        characterPath: `book-mvp-simple-adventure/order-generated-assets/characters/${CHARACTER_HASH}/`,\n      },\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5456,
        7136
      ],
      "id": "c51ae97f-994d-43f0-bded-b49745eef3ea",
      "name": "Stamp Pose Index Simulation"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -3696,
        7408
      ],
      "id": "59bba1e6-350e-4889-8a09-d89e14a63313",
      "name": "POSE_LOOP_SPLIT"
    },
    {
      "parameters": {
        "jsCode": "const audit = {\n  correlationId: $json.correlationId,\n  characterHash: $json.characterHash || $json.characterSpecs?.hash || null,\n  pose: $json.currentPoseNumber ?? $json.__meta?.poseNumber ?? null,\n  storageKey: $json.__meta?.storageKey || $json.r2Path || null,\n  fileUrl: $json.fileUrl || null,\n  generationConfig: $json.generationConfig || null,\n  ts: new Date().toISOString()\n};\nreturn [{ json: { ...$json, auditJson: JSON.stringify(audit, null, 2) } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        7424
      ],
      "id": "523d1ae5-283f-4968-944a-77692c67c229",
      "name": "r2 side-trace"
    },
    {
      "parameters": {
        "jsCode": "const j = $json;\nj.briaStatus = 'SKIPPED_DUE_TO_QUOTA';\nj.briaQuotaExceeded = true;\nj.requestId = null;\nj.statusUrl = null;\nj.submittedAt = j.submittedAt || new Date().toISOString();\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        704,
        7552
      ],
      "id": "bc7c4b53-1ac6-4658-bd9f-88d1a3e42711",
      "name": "Mark Bria Skipped"
    },
    {
      "parameters": {
        "jsCode": "console.log('Before loopback → items:', $input.all().length, 'pose:', $json.poseNumber);\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        7664
      ],
      "id": "60db27de-e0d1-4db3-8f76-797e1f1e3044",
      "name": "Count Before Loopback"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2752,
        7584
      ],
      "id": "8bcc05b0-8f0f-42ab-90a8-b2b859aac8bf",
      "name": "Response + Context"
    },
    {
      "parameters": {
        "jsCode": "// Build Dynamic Hairstyle Description — insert just BEFORE \"Prepare Binary\"\n// Adds: item.json.hairPromptBlock, hairPromptMeta (incl. hairColorHex + hairColorLock + clothing lock)\n// Preserves binary, aliases first unknown key to `image` if needed.\n\nconst item = $input.first();\nconst j = item.json || {};\nconst cs = j.characterSpecs || {};\n\n/* ---------------- Utils (local, but prefer globals if present) ---------------- */\nfunction norm(s){\n  return String(s||'')\n    .toLowerCase()\n    .replace(/[^a-z0-9#+\\-\\s]/g,' ')\n    .replace(/\\s+/g,' ')\n    .trim();\n}\n\n// If a Shared Utils node set global.canonicalClothingType, use it.\n// Otherwise define a compatible local fallback.\nconst canonicalClothingType = (global && typeof global.canonicalClothingType === 'function')\n  ? global.canonicalClothingType\n  : function canonicalClothingTypeLocal(raw){\n      const s = norm(raw);\n      if (!s) return 'tee-shorts';\n      if (/dress|sundress|gown/.test(s)) return 'dress';\n      // default → tee+shorts\n      return 'tee-shorts';\n    };\n\n/* ---------------- Hair style canonicalization (your live 13) ---------------- */\nconst CANONICAL_STYLES = [\n  'ponytail','pigtails',\n  'straight-short','straight-medium','straight-long',\n  'curly-short','curly-medium','curly-long',\n  'afro','pom-poms','bun','locs','side-part'\n];\n\nfunction canonicalStyle(styleRaw) {\n  const s = norm(styleRaw);\n  if (!s) return 'generic';\n  const sh = s.replace(/-/g,' ');\n  if (/(^|\\s)pom\\s*poms?($|\\s)|space\\s*buns?|puffs?/.test(sh)) return 'pom-poms';\n  if (/pigtails?/.test(sh)) return 'pigtails';\n  if (/side\\s*part/.test(sh)) return 'side-part';\n  if (/(^|\\s)bun($|\\s)/.test(sh)) return 'bun';\n  if (/(locs|dreadlocks|dreads)/.test(sh)) return 'locs';\n  if (/afro/.test(sh)) return 'afro';\n  if (/ponytail|pony\\s*tail/.test(sh)) return 'ponytail';\n\n  if (/straight/.test(sh) && /(short|above\\s*chin|chin)/.test(sh)) return 'straight-short';\n  if (/straight/.test(sh) && /(medium|shoulder|to\\s*shoulders?)/.test(sh)) return 'straight-medium';\n  if (/straight/.test(sh) && /(long|below\\s*shoulders?)/.test(sh)) return 'straight-long';\n  if (/straight/.test(sh)) return 'straight-medium';\n\n  if (/(curly|curls)/.test(sh) && /(short|halo)/.test(sh)) return 'curly-short';\n  if (/(curly|curls)/.test(sh) && /(medium|shoulder)/.test(sh)) return 'curly-medium';\n  if (/(curly|curls)/.test(sh) && /(long|below\\s*shoulders?)/.test(sh)) return 'curly-long';\n  if (/(curly|curls)/.test(sh)) return 'curly-medium';\n\n  return 'generic';\n}\n\n/* ---------------- Hair color canonicalization ---------------- */\n// Customer-facing labels → fixed HEX (your palette)\nconst HAIR_COLOR_MAP = {\n  'blonde':             { id:'blonde',            hex:'#D1B26F' },\n  'strawberry blonde':  { id:'strawberry-blonde', hex:'#E6A273' },\n  'light-brown':        { id:'light-brown',       hex:'#A4754A' },\n  'medium-brown':       { id:'medium-brown',      hex:'#7B4B2A' },\n  'dark-brown':         { id:'dark-brown',        hex:'#523418' },\n  'auburn':             { id:'auburn',            hex:'#8B3F2C' },\n  'black':              { id:'black',             hex:'#2B2B2B' },\n  'red':                { id:'red',               hex:'#C25E2E' }\n};\n\n// Accept many synonyms and raw hex like \"#734a2f\"\nfunction canonicalHairColor(raw){\n  const s = norm(raw);\n  if (!s) return { id:'unspecified', hex:null, source:'empty' };\n\n  // direct hex pass-through\n  const m = s.match(/#?[0-9a-f]{6}\\b/i);\n  if (m){\n    const hex = ('#' + m[0].replace('#','')).toUpperCase();\n    return { id:'custom-hex', hex, source:'hex' };\n  }\n\n  // normalize synonyms\n  const table = [\n    [/strawberry\\s*blonde|strawberry-blonde|strawberryblonde|strawb.*blonde/, 'strawberry blonde'],\n    [/light\\s*brown|lt\\s*brown|brown\\s*light/, 'light-brown'],\n    [/medium\\s*brown|mid\\s*brown|brown\\s*medium/, 'medium-brown'],\n    [/dark\\s*brown|dk\\s*brown|brown\\s*dark/, 'dark-brown'],\n    [/auburn|reddish\\s*brown/, 'auburn'],\n    [/ginger|copper|true\\s*red/, 'red'],\n    [/jet\\s*black|black/, 'black'],\n    [/blonde|blond/, 'blonde'],\n  ];\n  for (const [re,label] of table){\n    if (re.test(s)) return { ...HAIR_COLOR_MAP[label], source:'label' };\n  }\n\n  if (HAIR_COLOR_MAP[s]) return { ...HAIR_COLOR_MAP[s], source:'label-exact' };\n  return { id:'unspecified', hex:null, source:'unknown' };\n}\n\nconst colorIn = cs.hairColor || j.hairPromptMeta?.color || '';\nconst colorCanon = canonicalHairColor(colorIn);\n\n/* ---------------- Clothing type (now robust to style/type fields) ---------- */\nconst clothingTypeCanonical = canonicalClothingType(\n  cs.clothingType ?? cs.clothingStyle ?? j.clothingType ?? j.clothingStyle ?? j.clothingTypeCanonical\n) || 'tee-shorts';\n\n/* ---------------- Prompt map (same styles; side-part stricter) -------------- */\nconst PROMPT_MAP = {\n  'ponytail': [\n    'HAIRSTYLE — PONYTAIL',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Hair gathered into one ponytail; visible tie.',\n    '- Tail sits behind head/neck; no loose strands on face/shoulders.',\n    '- Tail reads as one connected mass.'\n  ],\n  'pigtails': [\n    'HAIRSTYLE — PIGTAILS (TWO PONYTAILS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Two mid-height ponytails with visible ties.',\n    '- Tails near shoulders without covering face.',\n    '- Each tail forms a closed silhouette; no flyaways.'\n  ],\n  'straight-short': [\n    'HAIRSTYLE — STRAIGHT (SHORT / ABOVE CHIN)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Short straight cut above chin; eyes fully clear.',\n    '- Silhouette hugs head; no stringy separated strands.'\n  ],\n  'straight-medium': [\n    'HAIRSTYLE — STRAIGHT (MEDIUM / TO SHOULDERS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Straight to shoulder length, falling behind shoulders.',\n    '- Neat part; no strands across eyes/cheeks.'\n  ],\n  'straight-long': [\n    'HAIRSTYLE — STRAIGHT (LONG / BELOW SHOULDERS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Long straight hair past shoulders, kept behind back.',\n    '- Minimal layering; tips not split/stringy.'\n  ],\n  'curly-short': [\n    'HAIRSTYLE — CURLY (SHORT / HALO)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Compact curl halo close to head.',\n    '- Suggest curls with interior shapes; outer contour continuous.'\n  ],\n  'curly-medium': [\n    'HAIRSTYLE — CURLY (MEDIUM / TO SHOULDERS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Medium curls to shoulder level.',\n    '- Group curls so outer silhouette stays continuous.'\n  ],\n  'curly-long': [\n    'HAIRSTYLE — CURLY (LONG / BELOW SHOULDERS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Long curls falling behind shoulders/back.',\n    '- Single connected outline; texture inside the shape.'\n  ],\n  'afro': [\n    'HAIRSTYLE — AFRO (ROUNDED)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Even, rounded afro around the head.',\n    '- Texture via tone; no pinholes to background.'\n  ],\n  'pom-poms': [\n    'HAIRSTYLE — POM-POMS / SPACE BUNS (TWO PUFFS)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Two symmetric puffs high on upper sides/crown; clean center part; small ties.',\n    '- SIZE: each ≤ 30% of head width; combined span ≤ 90%.',\n    '- PLACEMENT: above and slightly behind ears; do not overlap face.'\n  ],\n  'bun': [\n    'HAIRSTYLE — BUN (BACK/LOW BUN)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Single bun at back/low back of head.',\n    '- Front tidy; bun reads as one solid form.'\n  ],\n  'locs': [\n    'HAIRSTYLE — LOCS (NEATLY GATHERED)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- Locs arranged so overall outline remains continuous.',\n    '- Indicate individual locs with tone/lines; no gaps between locs.'\n  ],\n  'side-part': [\n    'HAIRSTYLE — SIDE-PART (SHORT CUT)',\n    colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n    '- PART: crisp side part on the character’s RIGHT (viewer’s LEFT); hair sweeps LEFT.',\n    '- LENGTH/SHAPE: short overall; both ears fully visible; sides/back tidy and close to the head.',\n    '- FRONT: one soft curved forelock sweeping sideways above the eyebrow region; no bob/bang curtain.',\n    '- SILHOUETTE LOCKS: outline hugs the skull; no hair below the top of the ear; back follows skull curve (no straight “bob” hem).',\n    '- NEGATIVES: no middle part; no long layers; no hair over cheeks/ears; no spikes/fade lines/flyaways.'\n  ]\n};\n\n/* ---------------- Hygiene (BG removal, shared) ---------------- */\nfunction hygieneLines(allowScallop) {\n  return [\n    '',\n    'HAIR OUTPUT POLICY (BG-REMOVAL):',\n    '- Hair renders as a single, opaque, connected mass.',\n    '- No gaps/holes; no semi-transparent strokes; no halos/outer glows.',\n    allowScallop ? '- For curly/afro/puffs, a gently scalloped outer edge is OK; keep it solid (no cutouts).' : null,\n    'BACKGROUND: Pure white (#FFFFFF). NO transparency.'\n  ].filter(Boolean);\n}\n\n/* ---------------- Hair reference usage block (if present) ---------------- */\nconst hasHairRef = !!(item.binary && item.binary.hair);\nconst hairRefUsageBlock = hasHairRef\n  ? [\n      '',\n      'IMAGE B — HAIRSTYLE REFERENCE (USAGE):',\n      '- Use ONLY for part location, silhouette outline, maximum length, and placement.',\n      '- Do NOT copy face, skin tone, eyes, clothes, or colors from IMAGE B — hair shape only.'\n    ].join('\\n')\n  : '';\n\n/* ---------------- Outfit/Clothing Lock (critical to stop swaps) ----------- */\nconst outfitLock =\n  clothingTypeCanonical === 'dress'\n    ? [\n        'OUTFIT / CLOTHING LOCK:',\n        '- Outfit MUST remain a DRESS (single-piece).',\n        '- Do NOT replace with a T-shirt and shorts, pants, or layered outfits.',\n        '- Keep the same dress silhouette as IMAGE A (short sleeves, A-line body); no waist seam or shorts hem visible.'\n      ].join('\\n')\n    : [\n        'OUTFIT / CLOTHING LOCK:',\n        '- Outfit MUST remain a short-sleeve T-SHIRT and SHORTS.',\n        '- Do NOT replace with a dress, skirt, pants, or layered outfits.',\n        '- Keep shorts length and T-shirt silhouette consistent with IMAGE A.'\n      ].join('\\n');\n\n/* ---------------- Build hair-color lock line ---------------- */\nconst hairColorLock = colorCanon.hex\n  ? `HAIR COLOR LOCK: Use ${colorCanon.hex} consistently across ALL generated images. Do not recolor, lighten/darken, or shift undertone.`\n  : 'HAIR COLOR LOCK: Keep the selected hair color consistent across ALL generated images. Do not recolor or shift undertone.';\n\n/* ---------------- Build final block ---------------- */\nconst styleKeyRaw = cs.hairStyle;\nconst styleKey = canonicalStyle(styleKeyRaw);\nconst allowScallop = ['curly-short','curly-medium','curly-long','afro','pom-poms'].includes(styleKey);\nconst baseLines = PROMPT_MAP[styleKey] || [\n  'HAIRSTYLE — GENERIC',\n  colorCanon.hex ? `Hair color base: ${colorCanon.hex}` : 'Hair color: unspecified',\n  '- Hair silhouette is a single connected mass with clean, closed edges.',\n  '- Keep interior detail with tone/lines; avoid gaps between strands.',\n  '- Keep face and ears unobstructed unless the style requires otherwise.'\n];\n\n// Recommended order: outfit lock → color lock → style → image usage → hygiene\nconst hairPromptBlock = [\n  outfitLock,\n  hairColorLock,\n  ...baseLines,\n  hairRefUsageBlock || null,\n  ...hygieneLines(allowScallop)\n].filter(Boolean).join('\\n');\n\n/* ---------------- Preserve & normalize binary for downstream ---------------- */\nconst binaryIn = item.binary || {};\nconst binaryKeys = Object.keys(binaryIn);\nconst preferredBinaryKeys = ['data','image','file','character','reference','hair'];\nconst hasPreferred = preferredBinaryKeys.some(k => binaryIn[k]);\nconst binaryOut = binaryKeys.length ? { ...binaryIn } : undefined;\nif (binaryOut && !hasPreferred && binaryKeys.length) {\n  const firstKey = binaryKeys[0];\n  binaryOut.image = binaryOut[firstKey];\n}\n\n/* ---------------- Emit ---------------- */\nreturn [{\n  json: {\n    ...j,\n    hairPromptBlock,\n    hairPromptMeta: {\n      ...(j.hairPromptMeta || {}),\n      styleKey: CANONICAL_STYLES.includes(styleKey) ? styleKey : 'generic',\n      colorLabel: colorCanon.id,\n      colorHex: colorCanon.hex,\n      hairColorLock,\n      clothingTypeCanonical, // for audit/debug and pose carry-over\n      promptVersion: 'v1.4-haircolor-lock+outfit-lock',\n      allowedKeys: CANONICAL_STYLES,\n      source: 'dynamic-hairstyle-prompt-map',\n      _debug: {\n        receivedHairStyle: styleKeyRaw,\n        receivedHairColor: colorIn,\n        hairColorSource: colorCanon.source,\n        normalizedStyle: norm(styleKeyRaw),\n        matchedStyleKey: CANONICAL_STYLES.includes(styleKey) ? styleKey : 'generic',\n        clothingTypeRaw: cs.clothingType ?? cs.clothingStyle ?? j.clothingType ?? j.clothingStyle,\n        hasHairRef\n      }\n    }\n  },\n  binary: binaryOut\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6256,
        7392
      ],
      "id": "e7f3000d-d664-47b1-8fec-0c1bbfc98ccc",
      "name": "Build Dynamic Hairstyle Prompt"
    },
    {
      "parameters": {
        "jsCode": "// Build Pose Prompt Description — WITH Subject Limit + Skin-Tone Lock + Hairstyle Lock\n// Inputs per item:\n//  - json.poseNumber (or parsed from names)\n//  - json.skinToneId (optional), json.skinHexBase (optional), json.skinColorLock (string you already pass)\n//  - json.hairPromptMeta.styleKey or json.hairStyleCanonical (optional but recommended)\n//  - json.characterSpecs.hairColor (optional)\n//  - binary: passthrough (no image generation here)\n// Output:\n//  - json.posePromptBlock (final ordered prompt text)\n//  - json.posePromptMeta\n\nconst items = $input.all();\nconst out = [];\n\n/* ---------------- Prefer Shared Utils (Globals) if present ---------------- */\nconst G = (typeof global !== 'undefined' && global) ? global : {};\n\n// norm()\nconst norm = (typeof G.norm === 'function')\n  ? G.norm\n  : function normLocal(s){\n      return String(s || '')\n        .toLowerCase()\n        .replace(/[^a-z0-9+\\-#\\s]/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n    };\n\n// parsePoseFromString()\nconst parsePoseFromString = (typeof G.parsePoseFromString === 'function')\n  ? G.parsePoseFromString\n  : function parsePoseFromStringLocal(s) {\n      if (!s) return null;\n      const str = String(s);\n      const m = str.match(/(?:pose[_\\- ]?(\\d{1,2}))|[_\\-\\.](\\d{1,2})(?:\\D|$)|\\/(\\d{1,2})\\.png$/i);\n      if (!m) return null;\n      return Number(m[1] || m[2] || m[3]);\n    };\n\n// clampPose()\nconst clampPose = (typeof G.clampPose === 'function')\n  ? G.clampPose\n  : function clampPoseLocal(n) { return Math.min(12, Math.max(1, Number(n))); };\n\n// canon() string normalizer for keys\nfunction canon(s){ return norm(s); }\n\n/* ---------------- Pose prompt map (unchanged) ---------------- */\nconst POSE_PROMPT_MAP = {\n  '1': `Walking step. Front foot forward and flat; rear heel slightly lifted. Torso upright, shoulders level. Natural counter-swing of arms (opposite arm forward to leading leg). Head facing forward; gaze ahead; gentle smile.`,\n  '2': `Walking while looking higher. Front foot forward; rear heel lifted. Elbows softly bent; hands near torso (light fists). Chin slightly raised; head tilted up and to the right; eyes looking above the horizon. Torso upright; shoulders level; friendly expression.`,\n  '3': `Standing and scanning the distance. Feet under hips, weight even. One hand across the brow as a visor (palm down, fingers together, elbow angled forward); the other arm relaxed at the side. Head turned slightly to the right; gaze far ahead; cheerful expression.`,\n  '4': `Floating/hovering. Both feet off the ground with toes pointed downward; knees softly bent. Arms extended slightly out from the sides (~30–45°), fingers relaxed. Torso upright; head forward; joyful expression. No running or walking motion.`,\n  '5': `Walking while looking down. Front foot forward and flat; rear heel subtly lifted. Arms relaxed with palms facing in, slight rearward swing. Chin tipped downward; eyes focused on the ground a step ahead of the toes. Torso upright; shoulders level; curious, gentle expression (not sad).`,\n  '6': `Jogging. Forward stride with the lead knee lifted; rear heel up. Elbows bent ~90°, hands in light fists at mid-torso; opposite arm leads the stride. Torso upright with a slight forward lean; head forward; eyes looking ahead. Focused, happy smile.`,\n  '7': `Sitting cross-legged and eating. Seated with legs crossed; feet tucked. Torso upright. Both hands hold a simple, unbranded sandwich near the mouth; elbows close to the body. Mouth open in a cheerful bite; eyes on the sandwich or slightly forward; delighted expression. Keep crumbs and sauce off; prop small and tidy.`,\n  '8': `Crouching/inspect. Deep squat with feet flat, hips close to heels. Forearms rest on thighs; hands relaxed near knees. Head tilted down and slightly forward; eyes focused on the ground directly in front. Mouth in a small “o” of wonder or soft smile; curious expression. Keep hair clear of face.`,\n  '9': `Crawling, moving, happy. On hands and knees; leading hand reaching forward while the opposite knee advances. Hips low; back long; torso angled ~30–45° above the ground. Head slightly raised; eyes looking forward and slightly downward along the path. Wide happy smile. Fingers relaxed (no pointing).`,\n  '10': `Surprised, looking up. Standing with feet under hips; slight lean back. Elbows bent with open hands near mid-torso (no waving). Chin lifted; head tilted up; eyes wide looking above. Mouth a small surprised “o”; eyebrows raised. Shoulders level.`,\n  '11': `Surprised (forward). Standing with feet under hips; slight recoil. Elbows bent; hands open and slightly out from the body at rib height. Head forward; eyes wide looking straight ahead. Mouth a small surprised “o”; eyebrows raised; shoulders level.`,\n  '12': `Flying/gliding. Body airborne; legs trailing slightly back with toes pointed. Arms extended out to the sides ~30–45° for balance; fingers relaxed. Torso angled slightly upward; head forward; eyes looking ahead; joyful, excited smile. Do not show running or walking contact with ground.`\n};\n\nconst POSE_ALLOWED_PROPS = { '7': ['sandwich'] };\n\n/* ---------------- Hairstyle lock (prefer Shared Utils if present) --------- */\nconst hairstyleLock = (typeof G.hairstyleLock === 'function')\n  ? G.hairstyleLock\n  : function hairstyleLockLocal(styleKey, color) {\n      const c = canon(styleKey);\n      const shared = [\n        'CONSISTENT HAIRSTYLE LOCK:',\n        '- Haircut is LOCKED to the base result (from IMAGE B when used). Do not change cut, part side, length, or ear visibility.',\n        '- Motion may deflect strands in the air, but the silhouette, part side, and maximum length remain unchanged.',\n        '- Hair renders as a single, opaque, connected mass; closed edges; no flyaways/halos.'\n      ];\n      const colorLine = color ? ['- Hair color: ' + color + ' (do not recolor).'] : [];\n\n      const map = {\n        'side-part': [\n          '- PART: on the character’s RIGHT (viewer’s LEFT); sweep LEFT in all poses.',\n          '- Both ears fully visible. No hair below the TOP of the ear.',\n          '- Back follows skull curve; absolutely no straight “bob” hem.',\n          '- Front forelock curves sideways above eyebrow region; never a bang curtain.'\n        ],\n        'ponytail': [\n          '- One ponytail gathered back with visible tie; tail sits behind head/neck (not over shoulders).',\n          '- No loose strands around face/cheeks.'\n        ],\n        'pigtails': [\n          '- Two mid-height ponytails with ties; each tail a solid mass.',\n          '- Do not cover the face; may sit near shoulders.'\n        ],\n        'bun': [\n          '- Single bun at back/low back; front remains tidy; no loose strands.'\n        ],\n        'pom-poms': [\n          '- Two puffs high on upper sides/crown; clean center part; small ties.',\n          '- Each puff ≤ 30% of head width; combined span ≤ 90%; do not overlap face.'\n        ],\n        'locs': [\n          '- Locs grouped neatly; overall outline continuous. Individual loc detail by tone/lines only.'\n        ],\n        'afro': [\n          '- Even rounded halo; silhouette stays continuous. No pinholes to background.'\n        ],\n        'straight-short': [\n          '- Short straight cut above chin; outline hugs head; eyes/ears clear.'\n        ],\n        'straight-medium': [\n          '- To-shoulders length; kept behind shoulders; no face coverage.'\n        ],\n        'straight-long': [\n          '- Below shoulders; hair trails behind back in motion but does not increase length.'\n        ],\n        'curly-short': [\n          '- Compact curl halo close to head; scalloped outer edge OK but continuous.'\n        ],\n        'curly-medium': [\n          '- Shoulder-level curls; group curls to keep continuous outline.'\n        ],\n        'curly-long': [\n          '- Long curls behind shoulders/back; no lace-like cutouts.'\n        ]\n      };\n\n      const specifics = map[c] || [];\n      return shared.concat(colorLine, specifics).join('\\n');\n    };\n\n/* ---------------- Main loop ---------------- */\nconst PREFERRED_BIN_KEYS = ['data','image','file','character','reference','pose','hair'];\n\nfor (const item of items) {\n  const j = item.json || {};\n  const binIn = item.binary || {};\n\n  // Binary passthrough + normalize first unknown to \"image\"\n  const binKeys = Object.keys(binIn);\n  const hasPreferred = PREFERRED_BIN_KEYS.some(k => binKeys.includes(k));\n  const binaryOut = binKeys.length ? { ...binIn } : undefined;\n  if (binaryOut && !hasPreferred && binKeys.length) {\n    const firstKey = binKeys[0];\n    binaryOut.image = binaryOut[firstKey];\n  }\n\n  // Resolve pose number (explicit → parse from names/paths)\n  let poseNum = j.poseNumber ?? j.currentPoseNumber ?? j.__meta?.poseNumber ?? null;\n  if (!Number.isFinite(Number(poseNum))) {\n    const candidates = [\n      j.poseRefName, j.poseRefFilename, j.poseRef, j.poseFileName,\n      j.poseRefUrl, j.poseUrl, j.posePath, j.imageUrl, j.sourceUrl\n    ];\n    for (const c of candidates) {\n      const p = parsePoseFromString(c);\n      if (Number.isFinite(p)) { poseNum = p; break; }\n    }\n  }\n  if (!Number.isFinite(Number(poseNum))) throw new Error('Build Pose Prompt: poseNumber missing/invalid.');\n  poseNum = clampPose(poseNum);\n\n  // Pose text\n  const poseText = (j.posePromptBlock && String(j.posePromptBlock).trim())\n    || (POSE_PROMPT_MAP[String(poseNum)] || '').trim();\n\n  // Style + locks context\n  const styleKey = j.hairPromptMeta?.styleKey || j.hairStyleCanonical || '';\n  // Prefer a hex if present, then label, then fallback to characterSpecs.hairColor\n  const hairColor = j.hairPromptMeta?.colorHex || j.hairPromptMeta?.color || j.characterSpecs?.hairColor || '';\n  const hairLockedLine = styleKey\n    ? 'Haircut is LOCKED to the base character. Do not change cut, part side, length, or ear visibility.'\n    : '';\n  const motionRule = 'Motion may deflect strands, but silhouette, part side, and max length remain unchanged.';\n  const hairLock = hairstyleLock(styleKey, hairColor);\n\n  // SUBJECT LIMIT\n  const subjectLimitLine = 'SUBJECT LIMIT: Exactly one child in frame (no additional people).';\n\n  // SKIN-TONE LOCK\n  const skinToneId = j.skinToneId || '';\n  const skinHexBase = j.skinHexBase || '';\n  const skinLockLines = [\n    'SKIN-TONE LOCK: Keep skin tone identical to base.',\n    skinToneId ? `- Palette: ${skinToneId}` : null,\n    skinHexBase ? `- Base hex: ${skinHexBase} (do not lighten/darken across images).` : null,\n    '- Maintain undertone; do not shift toward pink/gray/yellow; no freckles/blush unless requested.'\n  ].filter(Boolean).join('\\n');\n\n  // Color lock line (use the actual value from JSON if provided)\n  const colorLockLine = j.skinColorLock\n    ? `COLOR LOCK: ${j.skinColorLock} (keep consistent across all generated images).`\n    : null;\n\n  // Minimal style rules (concise to avoid token bloat)\n  const styleRulesBlock = [\n    'STYLE RULES:',\n    '- Match book style; smooth painted shapes; soft shading only.',\n    '- Background: pure white (#FFFFFF), no props, no text, no extra elements.',\n    '- Opaque strokes/fills; no semi-transparent halos.'\n  ].join('\\n');\n\n  // ORDERED MERGE\n  const mergedText = [\n    styleRulesBlock,                // 1) Style rules\n    subjectLimitLine,               // 2) Subject limit\n    skinLockLines,                  // 3) Skin-Tone Lock (with hex if provided)\n    colorLockLine,                  //    + your color lock line (only if present)\n    hairLockedLine,                 // 4) Hairstyle lock header\n    hairLock,                       //     (style-specific details)\n    motionRule,                     //     reminder about motion limits\n    poseText,                       // 5) Pose text\n    '',                             // spacer\n    'IMAGE NOTES:',                 // 6) Image annotations placeholder (images attached elsewhere)\n    '- IMAGE A — Base character style guide.',\n    '- IMAGE B — Hairstyle reference (hair only; no face/colors).',\n    '- IMAGE C — Skin-tone swatch (skin only; no hair/clothes).'\n  ].filter(Boolean).join('\\n');\n\n  const allowedProps = POSE_ALLOWED_PROPS[String(poseNum)] || [];\n\n  out.push({\n    json: {\n      ...j,\n      posePromptBlock: mergedText,\n      posePromptMeta: {\n        poseNumber: poseNum,\n        allowedProps,\n        version: 'v0.7-subject+skinlock+sharedutils',\n        source: 'pose-prompt-map+locks+ordered',\n        hairstyleKey: styleKey || 'unknown',\n        skinToneId: skinToneId || null,\n        skinHexBase: skinHexBase || null,\n        _binaryKeysPassed: binaryOut ? Object.keys(binaryOut) : []\n      }\n    },\n    binary: binaryOut\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3424,
        7504
      ],
      "id": "ab4c6b37-d4da-4980-bb00-7a5b85c53c52",
      "name": "Build Dynamic Pose Prompt"
    },
    {
      "parameters": {
        "jsCode": "// Resolve Hairstyle Key and Asset Path — utils-aware + robust fallbacks\n// Inputs: item.json.characterSpecs.hairStyle (optional), item.json.hairPromptMeta.styleKey (optional)\n// Outputs: hairStyleCanonical, hairRefS3Key, hairRefPublicUrl, hairPromptMeta (augmented)\n\nconst item = $input.first();\nconst j = item.json || {};\nconst cs = j.characterSpecs || {};\n\n// ---------- try to use Shared Utils (Init) norm() if available ----------\nlet U = {};\ntry { U = $('Shared Utils (Init)').first()?.json || {}; } catch {}\nconst norm = (typeof U?.fns?.norm === 'string')\n  ? eval(`(${U.fns.norm})`)\n  : function normLocal(s){\n      return String(s || '')\n        .toLowerCase()\n        .replace(/[^a-z0-9+\\-#\\s]/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n    };\n\n// 13 canonical styles\nconst CANONICAL = [\n  'ponytail','pigtails',\n  'straight-short','straight-medium','straight-long',\n  'curly-short','curly-medium','curly-long',\n  'afro','pom-poms','bun','locs','side-part'\n];\n\n// Canonicalizer tolerant to synonyms\nfunction canonicalStyle(styleRaw) {\n  const s = norm(styleRaw);\n  if (!s) return 'generic';\n  const sh = s.replace(/-/g, ' ');\n\n  if (/(^|\\s)pom\\s*poms?($|\\s)|space\\s*buns?|puffs?/.test(sh)) return 'pom-poms';\n  if (/pigtails?/.test(sh)) return 'pigtails';\n  if (/side\\s*part/.test(sh)) return 'side-part';\n  if (/(^|\\s)bun($|\\s)/.test(sh)) return 'bun';\n  if (/(locs|dreadlocks|dreads)/.test(sh)) return 'locs';\n  if (/afro/.test(sh)) return 'afro';\n  if (/ponytail|pony\\s*tail/.test(sh)) return 'ponytail';\n\n  if (/straight/.test(sh) && /(short|above\\s*chin|chin)/.test(sh)) return 'straight-short';\n  if (/straight/.test(sh) && /(medium|shoulder|to\\s*shoulders?)/.test(sh)) return 'straight-medium';\n  if (/straight/.test(sh) && /(long|below\\s*shoulders?)/.test(sh)) return 'straight-long';\n  if (/straight/.test(sh)) return 'straight-medium';\n\n  if (/(curly|curls)/.test(sh) && /(short|halo)/.test(sh)) return 'curly-short';\n  if (/(curly|curls)/.test(sh) && /(medium|shoulder)/.test(sh)) return 'curly-medium';\n  if (/(curly|curls)/.test(sh) && /(long|below\\s*shoulders?)/.test(sh)) return 'curly-long';\n  if (/(curly|curls)/.test(sh)) return 'curly-medium';\n\n  return 'generic';\n}\n\n// --- resolve the input style from multiple places (most authoritative first) ---\nconst styleKeyRaw =\n  j.hairPromptMeta?.styleKey ??\n  j.hairStyleCanonical ??\n  cs.hairStyle ??\n  j.hairStyle ??\n  cs.hair ??          // very defensive\n  j.hair ??           // very defensive\n  null;\n\n// Canonicalize (may return 'generic')\nlet hairStyleCanonical = canonicalStyle(styleKeyRaw);\n\n// If not canonical, try one more pass: if the raw itself is already canonical, accept it\nif (hairStyleCanonical === 'generic' && CANONICAL.includes(norm(styleKeyRaw))) {\n  hairStyleCanonical = norm(styleKeyRaw);\n}\n\n// Final guard: if still not canonical, **fallback instead of throwing**\nlet fallbackUsed = false;\nif (!CANONICAL.includes(hairStyleCanonical)) {\n  console.warn('Resolve Hairstyle: missing/unknown hairStyle, falling back to side-part. Raw:', styleKeyRaw);\n  hairStyleCanonical = 'side-part';\n  fallbackUsed = true;\n}\n\n// Base path — allow override via j.hairRefBasePrefix, else default\nconst basePrefix = (typeof j.hairRefBasePrefix === 'string' && j.hairRefBasePrefix.trim())\n  ? j.hairRefBasePrefix.replace(/\\/+$/,'')\n  : 'book-mvp-simple-adventure/characters/hairstyles';\n\nconst hairRefS3Key = `${basePrefix}/${hairStyleCanonical}.png`;\n\n// Optional public URL if r2PublicBase provided\nlet hairRefPublicUrl = undefined;\nif (typeof j.r2PublicBase === 'string' && j.r2PublicBase.trim()) {\n  const trimmed = j.r2PublicBase.replace(/\\/+$/,'');\n  hairRefPublicUrl = `${trimmed}/${hairRefS3Key}`;\n}\n\n// Merge meta\nconst hairPromptMeta = {\n  ...(j.hairPromptMeta || {}),\n  referenceKey: hairStyleCanonical,\n  referenceUrl: hairRefPublicUrl,\n  _resolver: {\n    source: 'resolve-hairstyle-key+asset-path',\n    receivedStyleRaw: styleKeyRaw ?? null,\n    fallbackUsed\n  }\n};\n\nreturn [{\n  json: {\n    ...j,\n    hairStyleCanonical,\n    hairRefS3Key,\n    hairRefPublicUrl,\n    hairPromptMeta\n  },\n  binary: item.binary,\n}];\n"
      },
      "id": "f9896e30-5d0b-42e4-bf0c-06cd30174ce9",
      "name": "Resolve Hairstyle Key & Asset Path",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7152,
        7520
      ]
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "={{$json.hairRefS3Key}}",
        "binaryPropertyName": "hair"
      },
      "id": "70696e2b-36a5-4dd2-916b-111a2b4a99e0",
      "name": "Load Hairstyle Reference (R2/S3)",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -6944,
        7520
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "d56b6706-9f56-4f63-8c35-73d0191bb447",
      "name": "Merge Base & Hair Refs",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -6672,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Gemini API request for CUSTOM BASE CHARACTER (hair ref optional, skin swatch optional)\n// + Clothing type & color locks (top-only color; neutral denim shorts) with HARD wardrobe override\n// Inputs:\n//  - JSON: characterSpecs.*, hairPromptBlock (+ hairPromptMeta, optional),\n//          requireHairRef (bool, optional), skinToneId (opt), skinHexBase (opt),\n//          skinColorLock (opt — human text like \"brown-03 #B47B50 within swatch range\"),\n//          characterSpecs.favoriteColor (label),\n//          characterSpecs.clothingType / clothingStyle (\"t-shirt and shorts\" | \"dress\" | synonyms)\n//  - Binary:\n//      • base style reference on any of ['data','image','file','character','reference']  ← IMAGE A\n//      • hairstyle reference (optional) on 'hair'                                        ← IMAGE B\n//      • skin-tone swatch chip/strip (optional) on 'skin'                                ← IMAGE C\n// Output:\n//  - item.json: { correlationId, generationConfig, requestBody, requestBodyMeta, clothing* fields }\n//  - (does not modify binary)\n\nconst item = $input.first();\nconst j = item.json || {};\nconst cs = j.characterSpecs || {};\n\n// ---------- helpers ----------\nfunction norm(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9#+\\-\\s]/g,' ').replace(/\\s+/g,' ').trim(); }\nfunction title(s){ return String(s||'').replace(/\\b\\w/g, c => c.toUpperCase()); }\n\n// ---------- clothing type canonicalization (prefer Shared Utils if available) ----------\nconst canonicalClothingType =\n  (typeof global !== 'undefined' && global && typeof global.canonicalClothingType === 'function')\n    ? global.canonicalClothingType\n    : function canonicalClothingTypeLocal(raw){\n        const s = norm(raw || '');\n        if (/dress|sundress|gown/.test(s)) return 'dress';\n        // default → tee+shorts\n        return 'tee-shorts';\n      };\n\nconst clothingTypeCanonical = canonicalClothingType(\n  cs.clothingType ?? cs.clothingStyle ?? j.clothingType ?? j.clothingStyle ?? j.clothingTypeCanonical\n) || 'tee-shorts';\n\n// Fixed neutral denim for shorts (muted to match book palette)\nconst SHORTS_HEX = '#5C7393';\n\n// ---------- favorite color (top or dress body) → HEX map ----------\nconst CLOTHING_COLOR_MAP = {\n  'red':      '#C8513C',\n  'orange':   '#DB8A2B',\n  'yellow':   '#E2C351',\n  'green':    '#76A355',\n  'blue':     '#4575A5',\n  'pink':     '#D77A8B',\n  'purple':   '#6E5A93',\n  'brown':    '#6B4E38',\n  'black':    '#212327'\n};\n\n// accept synonyms & raw hex\nfunction resolveTopColor(raw){\n  const s = norm(raw);\n  if (!s) return { label: 'unspecified', hex: null, source: 'empty' };\n\n  const m = s.match(/#?[0-9a-f]{6}\\b/i);\n  if (m){\n    const hex = ('#'+m[0].replace('#','')).toUpperCase();\n    return { label: 'custom-hex', hex, source: 'hex' };\n  }\n\n  const table = [\n    [/sky\\s*blue|navy|blue/, 'blue'],\n    [/lime|forest|green/, 'green'],\n    [/gold|sun|yellow/, 'yellow'],\n    [/peach|orange/, 'orange'],\n    [/rose|hot\\s*pink|pink/, 'pink'],\n    [/violet|lavender|purple/, 'purple'],\n    [/chocolate|brown/, 'brown'],\n    [/jet\\s*black|black/, 'black'],\n    [/scarlet|brick|red/, 'red'],\n  ];\n  for (const [re,label] of table){\n    if (re.test(s)) return { label, hex: CLOTHING_COLOR_MAP[label], source: 'label' };\n  }\n  if (CLOTHING_COLOR_MAP[s]) return { label: s, hex: CLOTHING_COLOR_MAP[s], source: 'label-exact' };\n  return { label: 'unspecified', hex: null, source: 'unknown' };\n}\nconst topColorIn = cs.favoriteColor || j.favoriteColor || cs.topColor || '';\nconst topColor = resolveTopColor(topColorIn);\n\n// ---------- 1) Resolve base reference binary ----------\nconst bin = item.binary || {};\nconst basePreferred = ['data','image','file','character','reference'];\nconst baseKey = basePreferred.find(k => bin[k]);\nif (!baseKey) {\n  throw new Error('Prepare Binary (Base): No base reference image found. Expected one of binary.' + basePreferred.join('|'));\n}\nlet baseBuf;\ntry { baseBuf = await this.helpers.getBinaryDataBuffer(0, baseKey); }\ncatch { throw new Error('Prepare Binary (Base): Failed to read base buffer from key \"' + baseKey + '\".'); }\nconst base64Base = baseBuf.toString('base64');\nif (!base64Base || base64Base.length < 100) throw new Error('Prepare Binary (Base): Base image base64 too short.');\nconst baseMime = (bin[baseKey] && bin[baseKey].mimeType) || 'image/png';\n\n// ---------- 2) Optional hairstyle & skin-swatch binaries ----------\nconst hasHair = !!bin.hair;\nif (j.requireHairRef === true && !hasHair) {\n  throw new Error('Prepare Binary (Base): hairstyle reference required (binary.hair) but missing.');\n}\n\nlet hair64 = null, hairMime = null;\nif (hasHair) {\n  try {\n    const hairBuf = await this.helpers.getBinaryDataBuffer(0, 'hair');\n    hair64 = hairBuf.toString('base64');\n    hairMime = (bin.hair && bin.hair.mimeType) || 'image/png';\n    if (!hair64 || hair64.length < 100) throw new Error('hair base64 too short');\n  } catch {\n    throw new Error('Prepare Binary (Base): Failed to read hairstyle reference from binary.hair.');\n  }\n}\n\n// Optional skin swatch\nlet skin64 = null, skinMime = null;\nconst hasSkin = !!bin.skin;\nif (hasSkin) {\n  try {\n    const skinBuf = await this.helpers.getBinaryDataBuffer(0, 'skin');\n    skin64 = skinBuf.toString('base64');\n    skinMime = (bin.skin && bin.skin.mimeType) || 'image/png';\n    if (!skin64 || skin64.length < 50) throw new Error('skin swatch base64 too short');\n  } catch {\n    skin64 = null; skinMime = null;\n  }\n}\n\n// ---------- 3) Build prompt text blocks (ordered) ----------\nconst styleKey = j.hairPromptMeta?.styleKey || j.hairStyleCanonical || norm(cs.hairStyle) || 'generic';\nconst hairColor = String(cs.hairColor || j.hairPromptMeta?.color || '').trim() || 'unspecified';\n\n// (A) Book style + BG rules\nconst styleRules = [\n  'BOOK STYLE: flat, clean vector-like forms with soft textured shading; no outlines on clothing folds.',\n  'BACKGROUND: pure white (#FFFFFF). No props, logos, or text. No transparency.'\n].join('\\n');\n\n// (B) SUBJECT LIMIT\nconst subjectLimit = 'SUBJECT LIMIT: Render exactly one child in frame. No additional people, duplicates, reflections, or background characters.';\n\n// (C) CLOTHING TYPE LOCK + COLOR LOCK (top only; fixed shorts) — with HARD OVERRIDE + NEGATIVES\nconst clothingTypeLine =\n  clothingTypeCanonical === 'dress'\n    ? [\n        'CLOTHING STYLE LOCK — DRESS (HARD OVERRIDE):',\n        '- Outfit must be a single-piece dress even if any reference image suggests otherwise.',\n        '- Ignore any cues for T-shirts, shorts, pants, skirts, or layered outfits.',\n        '- Dress silhouette: short sleeves or sleeveless OK; continuous skirt panel with no visible inseam; hem roughly mid-thigh; no leg openings that imply shorts.',\n      ].join('\\n')\n    : [\n        'CLOTHING STYLE LOCK — T-SHIRT & SHORTS:',\n        '- Short-sleeve T-shirt paired with shorts.',\n        '- No skirts, dresses, pants, or jackets.',\n      ].join('\\n');\n\nconst clothingNegatives =\n  clothingTypeCanonical === 'dress'\n    ? 'WARDROBE NEGATIVES (DRESS): No T-shirt seams/graphics, no waistband or fly, no leg cuffs, no pockets typical of shorts, no split at the crotch (no inseam).'\n    : null;\n\nconst topColorLock =\n  clothingTypeCanonical === 'dress'\n    ? (topColor.hex\n        ? `CLOTHING COLOR LOCK — DRESS BODY: Use ${topColor.hex} as the main fabric color. Keep hue constant across images; subtle book-style shading allowed; no recolor or saturation shifts.`\n        : 'CLOTHING COLOR LOCK — DRESS BODY: Keep a single solid color (per order) consistent across images; only subtle book-style shading allowed.')\n    : (topColor.hex\n        ? `CLOTHING COLOR LOCK — TOP ONLY: Use ${topColor.hex} for the T-shirt. Shorts must stay neutral denim ${SHORTS_HEX}. Keep hue constant; subtle shading allowed.`\n        : `CLOTHING COLOR LOCK — TOP ONLY: Keep a single solid color for the T-shirt (per order). Shorts must stay neutral denim ${SHORTS_HEX}.`);\n\nconst shortsRule = (clothingTypeCanonical === 'tee-shorts')\n  ? `SHORTS COLOR: Neutral denim ${SHORTS_HEX} (fixed). Do not recolor.`\n  : null;\n\n// (D) SKIN-TONE LOCK\nconst skinToneLine = (j.skinColorLock || j.skinToneId || j.skinHexBase)\n  ? [\n      'SKIN-TONE LOCK:',\n      j.skinColorLock\n        ? `- ${j.skinColorLock}`\n        : `- Use palette ${j.skinToneId || 'unspecified'} — base ${j.skinHexBase || '(missing hex)'}; keep highlights/shadows within the provided swatch; do not lighten/darken between images; do not change undertone.`\n    ].join('\\n')\n  : 'SKIN-TONE LOCK: Keep skin tone identical to the base reference across all outputs (no lightening/darkening; do not change undertone).';\n\n// (E) HAIRSTYLE LOCK\nconst hairLockShared = [\n  'HAIRSTYLE LOCK:',\n  '- Haircut is LOCKED to the base result (or IMAGE B if provided). Do not change cut, part side, ear visibility, or maximum length.',\n  '- Motion may deflect strands slightly, but silhouette/part/length remain unchanged.',\n  `- Hair color: ${hairColor} (do not recolor).`\n].join('\\n');\n\nconst perStyle = {\n  'side-part': [\n    '- PART: on the character’s RIGHT (viewer’s LEFT); sweep LEFT.',\n    '- Both ears fully visible. No hair below the TOP of the ear.',\n    '- Back follows skull curve; absolutely no straight “bob” hem.',\n    '- Forelock curves sideways above eyebrows; never a curtain bang.'\n  ],\n  'pom-poms': [\n    '- Two high puffs with small ties; clean center part.',\n    '- Each puff ≤30% head width; combined span ≤90%; do not overlap the face.'\n  ],\n  'ponytail': [\n    '- Single ponytail gathered back; sits behind head/neck; no loose face strands.'\n  ],\n  'pigtails': [\n    '- Two mid-height tails; solid masses; keep face/ears clear.'\n  ],\n  'afro': [\n    '- Even rounded halo; continuous outline without pinholes.'\n  ],\n  'locs': [\n    '- Grouped neatly; continuous outer outline; interior detail via tone/lines only.'\n  ]\n}[styleKey] || [];\nconst hairstyleLock = [hairLockShared].concat(perStyle).join('\\n');\n\n// (F) Image roles / annotations\nconst rolesLegend = [\n  'IMAGE ROLES:',\n  '- IMAGE A = base character style guide (bald/neutral head). Do not infer haircut from IMAGE A.',\n  '- IMAGE B = hairstyle reference (if present). Use ONLY for part location, silhouette, maximum length, and placement.',\n  '- IMAGE C = SKIN-TONE SWATCH (if present). SKIN COLORS ONLY — do not copy to hair/clothes.',\n  'Priority: if IMAGE A and IMAGE B ever conflict about hair, FOLLOW IMAGE B for silhouette/part/length.'\n].join('\\n');\n\nconst ann = j.hairPromptMeta?.annotations || {};\nconst annotLegend = (ann.partColor || ann.rightEarDotColor)\n  ? [\n      'ANNOTATION LEGEND (IMAGE B):',\n      ann.partColor ? (`- ${ann.partColor} line = hair part (character’s RIGHT / viewer’s LEFT).`) : null,\n      ann.rightEarDotColor ? (`- ${ann.rightEarDotColor} dot = right ear; keep BOTH ears fully visible.`) : null,\n    ].filter(Boolean).join('\\n')\n  : '';\n\n// Hair prompt block (fallback)\nconst hairPromptBlock = (j.hairPromptBlock && String(j.hairPromptBlock).trim()) || [\n  'HAIRSTYLE DESCRIPTION — GENERIC',\n  `- Color: ${hairColor}.`,\n  '- Hair silhouette is a single, opaque, connected mass with clean, closed edges.',\n  '- Keep face and both ears unobstructed unless the style requires otherwise.'\n].join('\\n');\n\n// Hygiene (BG removal)\nconst hygiene = [\n  'HAIR OUTPUT POLICY:',\n  '- Hair renders as a single, opaque, connected mass; closed edges.',\n  '- No halos, gaps, or semi-transparent strokes.'\n].join('\\n');\n\n// Compose final user text (recommended order)\nconst userTextParts = [\n  // 1) Style rules\n  styleRules,\n  // 2) Subject limit\n  subjectLimit,\n  // 3) Clothing locks (type + colors)\n  clothingTypeLine,\n  clothingNegatives,\n  topColorLock,\n  shortsRule,\n  // 4) Skin tone lock\n  skinToneLine,\n  // 5) Hairstyle lock\n  hairstyleLock,\n  // 6) Image roles & legends\n  rolesLegend,\n  annotLegend || null,\n  hairPromptBlock,\n  hygiene\n].filter(Boolean);\nconst userText = userTextParts.join('\\n\\n');\n\n// ---------- 4) System & generation config ----------\nconst systemText = [\n  'You are a precise illustration tool.',\n  'CRITICAL: Preserve EXACT requested traits. Use IMAGE A only for overall style; use IMAGE B only for hair; use IMAGE C only for skin color matching.',\n  'Do not add text, logos, props, or backgrounds.'\n].join('\\n');\n\nconst generationConfig = {\n  imageConfig: { aspectRatio: '1:1' },\n  temperature: 0.3\n};\n\n// ---------- 5) Build request body (images last) ----------\nconst parts = [];\nparts.push({ text: userText });\n\n// IMAGE A — base\nparts.push({ text: 'IMAGE A — BASE STYLE GUIDE (do not infer haircut).' });\nparts.push({ inlineData: { mimeType: baseMime, data: base64Base } });\n\n// IMAGE B — hairstyle ref (optional)\nif (hasHair && hair64) {\n  parts.push({ text: 'IMAGE B — HAIRSTYLE REFERENCE. Use ONLY for hair silhouette/part/length/placement. Do not copy face/skin/eyes/clothes.' });\n  parts.push({ inlineData: { mimeType: hairMime, data: hair64 } });\n}\n\n// IMAGE C — skin-tone swatch (optional)\nif (hasSkin && skin64) {\n  parts.push({ text: 'IMAGE C — COLOR SWATCH (SKIN ONLY). Match base/highlight/shadow exactly. Do NOT apply to hair/clothes.' });\n  parts.push({ inlineData: { mimeType: skinMime, data: skin64 } });\n}\n\nconst requestBody = {\n  systemInstruction: { role: 'system', parts: [{ text: systemText }] },\n  contents: [{ parts }],\n  generationConfig\n};\n\n// ---------- 6) Trace meta & correlation ----------\nconst characterHash = j.characterHash || cs.hash || 'nohash';\nconst correlationId = characterHash + '-BASE-' + Date.now();\n\nreturn [{\n  json: {\n    ...j,\n    correlationId,\n    generationConfig,\n    requestBody,\n    requestBodyMeta: {\n      hasHairRef: !!hair64,\n      hasSkinSwatch: !!skin64,\n      hairStyleKey: styleKey,\n      hairRefKey: j.hairRefS3Key || null,\n      baseBinaryKey: baseKey,\n      skinToneId: j.skinToneId || null,\n      skinHexBase: j.skinHexBase || null\n    },\n    // clothing metadata to carry into pose loop\n    clothingTypeCanonical,\n    clothingColorLabel: topColor.label,\n    clothingColorHex: topColor.hex,\n    shortsHex: SHORTS_HEX\n  },\n  binary: item.binary\n}];\n"
      },
      "id": "e0f2db0c-5937-45ed-8eed-78b11e0335dc",
      "name": "Prepare Binary (Base Gen, dual-image)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6032,
        7392
      ]
    },
    {
      "parameters": {
        "jsCode": "// Inputs: item.json.characterSpecs.skinTone, .clothingType (free text from UI)\n// Outputs: item.json.skinToneCanonical, .skinToneLabel,\n//          .clothingTypeCanonical, .clothingTypeLabel,\n//          .baseRefS3Key, .baseRefPublicUrl\n\nconst item = $input.first();\nconst j = item.json || {};\nconst cs = j.characterSpecs || {};\n\nconst PUBLIC_BASE = 'https://pub-92cec53654f84771956bc84dfea65baa.r2.dev';\nconst ASSET_ROOT  = 'book-mvp-simple-adventure/characters/bases';\n\n// ------------------------- helpers -------------------------\nfunction norm(s){\n  return String(s||'').toLowerCase().replace(/[^a-z0-9+\\-\\s]/g,' ').replace(/\\s+/g,' ').trim();\n}\n\n// ---------- Skin tone canonicalization ----------\nfunction canonicalSkinTone(raw){\n  const s = norm(raw);\n\n  if (!s) return 'skin-medium';\n\n  // accept explicit legacy keys too\n  if (/(^|[^a-z])skin[-_ ]?(light|tan|medium|brown[-_ ]light|brown[-_ ]deep|dark[-_ ]aa|light[-_ ]aa)([^a-z]|$)/.test(s)) {\n    if (/brown[-_ ]light|light[-_ ]aa/.test(s)) return 'skin-brown-light';\n    if (/brown[-_ ]deep|dark[-_ ]aa/.test(s))  return 'skin-brown-deep';\n    if (/skin[-_ ]light/.test(s))               return 'skin-light';\n    if (/skin[-_ ]tan/.test(s))                 return 'skin-tan';\n    return 'skin-medium';\n  }\n\n  // new labels & broad synonyms\n  if (/(brown).*(deep|dark)|\\b(deep|dark)\\b.*(brown|african|aa|black)/.test(s)) return 'skin-brown-deep';\n  if (/(brown).*(light)|\\blight\\b.*(brown|african|aa|black)|(light)\\s*(aa|african)/.test(s)) return 'skin-brown-light';\n  if (/^(light|fair)(\\b|$)/.test(s))                      return 'skin-light';\n  if (/(tan|olive)/.test(s))                              return 'skin-tan';\n  if (/(medium|mid|default|normal|average)/.test(s))      return 'skin-medium';\n\n  // very old phrasing\n  if (/(dark).*?(african|aa|black)/.test(s))              return 'skin-brown-deep';\n  if (/(light).*?(african|aa|black)/.test(s))             return 'skin-brown-light';\n\n  return 'skin-medium';\n}\n\nconst skinToneCanonical = canonicalSkinTone(cs.skinTone);\n\n// customer-facing skin labels\nconst CANONICAL_TO_SKIN_LABEL = {\n  'skin-light':       'Light',\n  'skin-tan':         'Tan',\n  'skin-medium':      'Medium',\n  'skin-brown-light': 'Brown — Light',\n  'skin-brown-deep':  'Brown — Deep',\n};\nconst skinToneLabel = CANONICAL_TO_SKIN_LABEL[skinToneCanonical] || CANONICAL_TO_SKIN_LABEL['skin-medium'];\n\n// --- Clothing type canonicalization ---\nconst rawClothing =\n  (cs.clothingType ?? cs.clothingStyle ?? j.clothingType ?? j.clothingStyle ?? '').toString();\n\nfunction canonicalClothing(raw){\n  const s = norm(raw);\n  if (!s) return 'tee-shorts';\n  if (/(^|\\b)dress(es)?($|\\b)/.test(s)) return 'dress';\n  if (/(t[\\-\\s]?shirt|tee)\\b/.test(s) && /\\bshorts?\\b/.test(s)) return 'tee-shorts';\n  if (/\\bshorts?\\b/.test(s)) return 'tee-shorts';\n  if (/tee|tshirt|t\\-shirt/.test(s)) return 'tee-shorts';\n  return 'tee-shorts';\n}\nconst clothingTypeCanonical = canonicalClothing(rawClothing);\n\n\n// clothing labels for audit/UI echo\nconst CLOTHING_LABELS = {\n  'tee-shorts': 'T-shirt & shorts',\n  'dress':      'Dress',\n};\nconst clothingTypeLabel = CLOTHING_LABELS[clothingTypeCanonical] || 'T-shirt & shorts';\n\n// ---------- Filename map (mixed extensions preserved) ----------\nconst FILENAME_MAP = {\n  'tee-shorts': {\n    'skin-brown-deep':  'base--skin-dark-aa.png',\n    'skin-brown-light': 'base--skin-light-aa.png',\n    'skin-light':       'base--skin-light.png',\n    'skin-medium':      'base--skin-medium.jpg',     // only JPG\n    'skin-tan':         'base--skin-tan.png',\n  },\n  'dress': {\n    'skin-brown-deep':  'base--skin-dark-aa--dress.png',\n    'skin-brown-light': 'base--skin-light-aa--dress.png',\n    'skin-light':       'base--skin-light--dress.png',\n    'skin-medium':      'base--skin-medium--dress.png',\n    'skin-tan':         'base--skin-tan--dress.png',\n  }\n};\n\nconst clothingTable = FILENAME_MAP[clothingTypeCanonical] || FILENAME_MAP['tee-shorts'];\nconst filename = clothingTable[skinToneCanonical] || clothingTable['skin-medium'];\n\nconst baseRefS3Key = `${ASSET_ROOT}/${filename}`;\nconst baseRefPublicUrl = `${PUBLIC_BASE}/${baseRefS3Key}`;\n\n// ---------- Emit ----------\nreturn [{\n  json: {\n    ...j,\n    skinToneCanonical,\n    skinToneLabel,\n    clothingTypeCanonical,\n    clothingTypeLabel,\n    baseRefS3Key,\n    baseRefPublicUrl,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7152,
        7280
      ],
      "id": "5657c2f7-5bfa-4db4-9ae6-8db9cd6b60c4",
      "name": "Resolve Skin Tone & Base Path"
    },
    {
      "parameters": {
        "bucketName": "=little-hero-assets",
        "fileKey": "={{ $json.baseRefS3Key }}"
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -6944,
        7280
      ],
      "id": "62dcc0ac-1d2e-4632-badc-9921b92632d0",
      "name": "Load Base Character Image",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nreturn [{\n  json: {\n    ...item.json,\n    poseMeta: {\n      ...(item.json.poseMeta || {}),\n      skinToneCanonical: item.json.skinToneCanonical || 'skin-medium',\n    }\n  },\n  binary: item.binary  // pass through (data + hair, if present)\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -6464,
        7392
      ],
      "id": "be495e30-bf55-4945-8107-2f79a50b0da7",
      "name": "Canonical Skin Ton Preserver"
    }
  ],
  "pinData": {},
  "connections": {
    "Generate Mock Order": {
      "main": [
        [
          {
            "node": "Get Next Order from Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Generate Mock Order",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Character in Pose": {
      "main": [
        [
          {
            "node": "Response + Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Generated Image": {
      "main": [
        [
          {
            "node": "Filter: Only Items With Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DIAGNOSTIC: Check Fields": {
      "main": [
        []
      ]
    },
    "Filter: Only Items With Images": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Next Order from Queue": {
      "main": [
        [
          {
            "node": "Generate Character Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Character Hash": {
      "main": [
        [
          {
            "node": "Resolve Skin Tone & Base Path",
            "type": "main",
            "index": 0
          },
          {
            "node": "Resolve Hairstyle Key & Asset Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Custom Base Character": {
      "main": [
        [
          {
            "node": "Process Gemini API response and extract generated image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare binary": {
      "main": [
        []
      ]
    },
    "Process Gemini API response and extract generated image": {
      "main": [
        [
          {
            "node": "Upload a file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload a file": {
      "main": [
        [
          {
            "node": "Restore Metadata After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Metadata After Upload": {
      "main": [
        [
          {
            "node": "Load Custom Character from R2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Custom Character from R2": {
      "main": [
        [
          {
            "node": "Initialize Pose Generation Loop",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Pose Generation Loop": {
      "main": [
        [
          {
            "node": "Load Pose Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Pose Reference": {
      "main": [
        [
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Character with Poses": {
      "main": [
        [
          {
            "node": "Reorganize Merged Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reorganize Merged Data": {
      "main": [
        [
          {
            "node": "POSE_LOOP_SPLIT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gemini Requests": {
      "main": [
        [
          {
            "node": "Generate Character in Pose",
            "type": "main",
            "index": 0
          },
          {
            "node": "Response + Context",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Stamp Pose Index",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Submit to Bria AI": {
      "main": [
        [
          {
            "node": "Mark Bria Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Submission Result": {
      "main": [
        [
          {
            "node": "Wait 6 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 6 Seconds": {
      "main": [
        [
          {
            "node": "Count Before Loopback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Final Summary": {
      "main": [
        [
          {
            "node": "Wait 90 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 90 Seconds": {
      "main": [
        [
          {
            "node": "Trigger Workflow B",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Drop Heavy Fields": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Capture Lean Meta": {
      "main": [
        [
          {
            "node": "Make Binary from Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Make Binary from Base64": {
      "main": [
        [
          {
            "node": "If (should upload?)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Add Upload to R2": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Set Meta Path": {
      "main": [
        [
          {
            "node": "r2 side-trace",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Image URL (200)": {
      "main": [
        [
          {
            "node": "URL OK or fallback to base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "URL OK or fallback to base64": {
      "main": [
        [
          {
            "node": "Build Bria Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Bria Payload": {
      "main": [
        [
          {
            "node": "Submit to Bria AI",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If (should upload?)": {
      "main": [
        [
          {
            "node": "Add Upload to R2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Upload Pass-through",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Binary After Upload": {
      "main": [
        [
          {
            "node": "Set Meta Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Upload Pass-through": {
      "main": [
        [
          {
            "node": "Clean Binary After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stamp Pose Index": {
      "main": [
        [
          {
            "node": "Capture Lean Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Clean Binary After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Store Submission Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Stamp Pose Output (Sim)": {
      "main": [
        []
      ]
    },
    "Download Image": {
      "main": [
        [
          {
            "node": "Build Stamp Pose Output (Sim)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Capture Lean Meta": {
      "main": [
        [
          {
            "node": "Make Binary from Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Store Submission Result": {
      "main": [
        [
          {
            "node": "Wait 6 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FOR TESTING - Create Final Summary": {
      "main": [
        [
          {
            "node": "Wait 90 Seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stamp Pose Index Simulation": {
      "main": [
        [
          {
            "node": "Download Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "POSE_LOOP_SPLIT": {
      "main": [
        [
          {
            "node": "Create Final Summary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Dynamic Pose Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "r2 side-trace": {
      "main": [
        [
          {
            "node": "Check Image URL (200)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Bria Skipped": {
      "main": [
        [
          {
            "node": "Drop Heavy Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count Before Loopback": {
      "main": [
        [
          {
            "node": "POSE_LOOP_SPLIT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response + Context": {
      "main": [
        [
          {
            "node": "Extract Generated Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Dynamic Hairstyle Prompt": {
      "main": [
        [
          {
            "node": "Prepare Binary (Base Gen, dual-image)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Dynamic Pose Prompt": {
      "main": [
        [
          {
            "node": "Prepare Gemini Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Hairstyle Key & Asset Path": {
      "main": [
        [
          {
            "node": "Load Hairstyle Reference (R2/S3)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Hairstyle Reference (R2/S3)": {
      "main": [
        [
          {
            "node": "Merge Base & Hair Refs",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Base & Hair Refs": {
      "main": [
        [
          {
            "node": "Canonical Skin Ton Preserver",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Binary (Base Gen, dual-image)": {
      "main": [
        [
          {
            "node": "Generate Custom Base Character",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Resolve Skin Tone & Base Path": {
      "main": [
        [
          {
            "node": "Load Base Character Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Base Character Image": {
      "main": [
        [
          {
            "node": "Merge Base & Hair Refs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Canonical Skin Ton Preserver": {
      "main": [
        [
          {
            "node": "Build Dynamic Hairstyle Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "125b1317-7f89-471d-a803-0a804059a611",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "010748b7a1466c46dced3f8b2bdbc3bc174722f0672e5a4c9529354f5ff306f8"
  },
  "id": "tU1hnPVIrPl958H2",
  "tags": []
}