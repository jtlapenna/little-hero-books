{
  "name": "LHB - 2- Character Creation - WORKING NEW",
  "nodes": [
    {
      "parameters": {
        "functionCode": "// Get next order from processing queue and extract custom elements\n// In production, this would query a database queue\n// For now, we'll simulate getting an order from the previous workflow\n\nconst inputData = $input.first();\nif (!inputData || !inputData.json) {\n  console.log('No input data received');\n  return [];\n}\n\nconst orderData = inputData.json;\n\n// Check if order is ready for AI generation\nif (orderData.status !== 'queued_for_processing') {\n  console.log(`Order ${orderData.amazonOrderId} not ready for processing. Status: ${orderData.status}`);\n  return []; // Skip if not ready\n}\n\n// Extract and validate custom elements from characterSpecs\nconst characterSpecs = orderData.characterSpecs || {};\nconst customElements = {\n  childName: characterSpecs.childName || 'Adventure Hero',\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Update order status to processing with custom elements\nconst processingOrder = {\n  ...orderData,\n  characterSpecs: customElements,\n  status: 'ai_generation_in_progress',\n  aiGenerationStartedAt: new Date().toISOString(),\n  posesGenerated: 0,\n  totalPosesRequired: 12,\n  generationProgress: 0\n};\n\nconsole.log(`Starting AI generation for order: ${orderData.amazonOrderId}`);\nconsole.log(`Custom elements:`, customElements);\nreturn [{ json: processingOrder }];"
      },
      "id": "63b2e92d-864c-4324-907b-c9f4a598b2c6",
      "name": "Get Next Order from Queue",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -4800,
        464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate character hash for reuse detection\nconst orderData = $input.first().json;\nconst characterSpecs = orderData.characterSpecs || {};\n\n// Create a normalized character specification object for hashing\n// Exclude childName and other order-specific data\nconst characterHashSpec = {\n  skinTone: characterSpecs.skinTone || 'medium',\n  hairColor: characterSpecs.hairColor || 'brown',\n  hairStyle: characterSpecs.hairStyle || 'short/straight',\n  age: parseInt(characterSpecs.age) || 5,\n  pronouns: characterSpecs.pronouns || 'they/them',\n  favoriteColor: characterSpecs.favoriteColor || 'blue',\n  animalGuide: characterSpecs.animalGuide || 'dog',\n  clothingStyle: characterSpecs.clothingStyle || 't-shirt and shorts'\n};\n\n// Generate a deterministic hash from the character specifications\nconst crypto = require('crypto');\nconst hashString = JSON.stringify(characterHashSpec, Object.keys(characterHashSpec).sort());\nconst characterHash = crypto.createHash('sha256').update(hashString).digest('hex').substring(0, 16);\n\n// Add character hash and normalized specs to order data\nconst orderWithHash = {\n  ...orderData,\n  characterHash: characterHash,\n  characterHashSpec: characterHashSpec,\n  characterPath: `characters/${characterHash}`,\n  templatePath: 'templates'\n};\n\nconsole.log(`Generated character hash: ${characterHash}`);\nconsole.log(`Character specs:`, characterHashSpec);\n\nreturn [{ json: orderWithHash }];"
      },
      "id": "f15aa745-afb0-4fe1-ae82-0511a9a6391f",
      "name": "Generate Character Hash",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4624,
        464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Restore metadata after S3 upload (S3 nodes replace JSON output)\nconst uploadResult = $input.first();\nconst originalData = $('Process Gemini API response and extract generated image').first();\n\n// DEBUG: Check what we're getting from the original data\nconsole.log('DEBUG: Original data from Process Gemini API response:', {\n  hasBinary: !!originalData.binary,\n  hasBinaryData: !!(originalData.binary && originalData.binary.data),\n  binaryKeys: originalData.binary ? Object.keys(originalData.binary) : 'no binary',\n  jsonKeys: Object.keys(originalData.json)\n});\n\n// For now, just restore the metadata. We'll get binary data directly in Prepare Gemini Requests\nreturn [{\n  json: {\n    ...originalData.json, // All the metadata including characterPath and characterHash!\n    s3UploadResult: uploadResult.json, // S3 response\n    baseCharacterUploaded: true,\n    baseCharacterUploadedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "bd3bf6b1-03e7-4228-ae9a-ef5b14588e86",
      "name": "Restore Metadata After Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3568,
        464
      ]
    },
    {
      "parameters": {
        "functionCode": "// Initialize pose generation loop - Use existing files from R2\nconst orderData = $input.first().json;\n\n// Use all 12 poses that exist in R2: pose01.png through pose12.png\nconst existingPoses = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n\nconsole.log(`Using existing poses: ${existingPoses.join(', ')}`);\nconsole.log('Order data:', orderData);\n\n// Create array of poses to generate\nconst posesToGenerate = existingPoses.map(poseNumber => ({\n  ...orderData,\n  currentPoseNumber: poseNumber,\n  poseStatus: 'pending',\n  poseGenerationAttempts: 0,\n  maxPoseAttempts: 3\n}));\n\nconsole.log(`Initialized pose generation for ${posesToGenerate.length} poses:`, posesToGenerate.map(p => p.currentPoseNumber));\nreturn posesToGenerate.map(pose => ({ json: pose }));"
      },
      "id": "c7aef322-a54b-477e-805f-363b8954432d",
      "name": "Initialize Pose Generation Loop",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -3232,
        624
      ]
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "={{ $json.characterPath }}/base-character.png"
      },
      "id": "9dcc84fe-ce4b-4947-82ee-622f1c051109",
      "name": "Load Custom Character from R2",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -3392,
        464
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "bucketName": "little-hero-assets",
        "fileKey": "=book-mvp-simple-adventure/characters/poses/pose{{ $json.currentPoseNumber.toString().padStart(2, '0') }}.png"
      },
      "id": "90e22fce-7430-4069-a8e8-28d6eb44cfd1",
      "name": "Load Pose Reference",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -3040,
        624
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {},
      "id": "64670576-2482-48e4-8502-7b1030633145",
      "name": "Merge Character with Poses",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -2848,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Reorganize merged data: duplicate character across all pose items\nconst items = $input.all();\nconst loopItems = $('Initialize Pose Generation Loop').all();\nconst characterLoadItem = $('Load Custom Character from R2').first();\n\nconsole.log('DEBUG: After merge:', {\n  totalItems: items.length,\n  item0HasBinary: items.length > 0 ? !!items[0].binary : false,\n  item1HasBinary: items.length > 1 ? !!items[1].binary : false\n});\n\n// Handle 13 items (1 character + 12 poses)\nif (items.length !== 13) {\n  throw new Error(`Expected 13 items (1 character + 12 poses), got ${items.length}`);\n}\n\n// First item is the character\nconst characterItem = items[0];\nconst characterBuffer = await this.helpers.getBinaryDataBuffer(0, 'data');\nconst characterBase64 = characterBuffer.toString('base64');\n\nif (!characterBase64 || characterBase64.length < 100) {\n  throw new Error('Invalid character binary');\n}\n\n// Get character metadata from the character load item\nconst characterPath = characterLoadItem.json.characterPath;\nconst characterHash = characterLoadItem.json.characterHash;\n\nconsole.log('DEBUG: Character metadata:', {\n  characterPath: characterPath,\n  characterHash: characterHash,\n  characterBase64Length: characterBase64.length\n});\n\n// Items 1-12 are the poses\nconst results = [];\nfor (let i = 1; i < items.length; i++) {\n  const poseItem = items[i];\n  const loopItem = loopItems[i - 1]; // Offset by 1 since poses start at index 1\n  \n  // Get pose binary\n  const poseBuffer = await this.helpers.getBinaryDataBuffer(i, 'data');\n  const poseBase64 = poseBuffer.toString('base64');\n  \n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Invalid pose binary for item ${i}`);\n  }\n  \n  const currentPoseNumber = loopItem.json.currentPoseNumber;\n  \n  console.log(`DEBUG: Pose ${i}:`, {\n    poseNumber: currentPoseNumber,\n    characterSize: characterBase64.length,\n    poseSize: poseBuffer.length,\n    hasCharacterBase64: !!characterBase64,\n    hasPoseBase64: !!poseBase64\n  });\n  \n  // Create output with both character and pose\n  results.push({\n    json: {\n      ...loopItem.json,\n      characterBase64: characterBase64,\n      poseBase64: poseBase64,\n      characterPath: characterPath,\n      characterHash: characterHash,\n      poseNumber: currentPoseNumber,\n      currentPoseNumber: currentPoseNumber,\n      _merged: true,\n      _mergeDebug: {\n        characterSize: characterBase64.length,\n        poseSize: poseBase64.length,\n        poseNumber: currentPoseNumber,\n        characterPath: characterPath,\n        characterHash: characterHash\n      }\n    }\n  });\n}\n\nconsole.log('DEBUG: Final results:', {\n  numResults: results.length,\n  firstResultHasCharBase64: results.length > 0 ? !!results[0].json.characterBase64 : false,\n  firstResultHasPoseBase64: results.length > 0 ? !!results[0].json.poseBase64 : false,\n  firstResultHasCharacterPath: results.length > 0 ? !!results[0].json.characterPath : false,\n  firstResultHasPoseNumber: results.length > 0 ? !!results[0].json.poseNumber : false\n});\n\nreturn results;"
      },
      "id": "fb927a0b-8b71-4700-8a8d-66f01451615e",
      "name": "Reorganize Merged Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2656,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Gemini API request with character and pose images\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  // Get the base64 data directly from the JSON\n  const characterBase64 = item.json.characterBase64;\n  const poseBase64 = item.json.poseBase64;\n  const currentPoseNumber = item.json.currentPoseNumber;\n  const characterSpecs = item.json.characterSpecs;\n  \n  // Safety checks\n  if (!characterBase64 || characterBase64.length < 100) {\n    throw new Error(`Character base64 data missing or invalid for pose ${currentPoseNumber}`);\n  }\n  if (!poseBase64 || poseBase64.length < 100) {\n    throw new Error(`Pose base64 data missing or invalid for pose ${currentPoseNumber}`);\n  }\n  if (!characterSpecs) {\n    throw new Error(`Character specifications missing for pose ${currentPoseNumber}`);\n  }\n\n  const systemText = `You are a precise illustration tool. CRITICAL: You must preserve the EXACT appearance from IMAGE A. IMAGE B is ONLY for body position - ignore ALL visual traits from IMAGE B. CONFLICT RULE: Always follow IMAGE A for appearance.`;\n\n  const promptText = `ULTRA-CRITICAL INSTRUCTION:\nYou must generate ONE image that combines:\n- The EXACT character appearance from IMAGE A (skin tone, hair color, hair length, hair style, clothing, facial features)\n- The EXACT body pose and position from IMAGE B (stance, limb positions, body angle)\n\nMANDATORY APPEARANCE TRAITS (from IMAGE A - DO NOT CHANGE):\n- Hair: ${characterSpecs.hairColor} ${characterSpecs.hairLength} ${characterSpecs.hairStyle} hair\n- Skin: ${characterSpecs.skinTone} skin tone\n- Clothing: ${characterSpecs.clothingTop} and ${characterSpecs.shoes}\n- Age: ${characterSpecs.age} years old\n\nABSOLUTELY FORBIDDEN:\n- Changing hair color from IMAGE A\n- Changing hair length from IMAGE A\n- Changing hair style from IMAGE A\n- Copying any appearance traits from IMAGE B\n- Mixing or blending the two characters\n- Generating extra limbs, overlapping body parts, or deformed bodies\n- Creating duplicate or overlapping leg structures\n- Adding extra arms, legs, or body parts\n\nREQUIREMENTS:\n- Style: Watercolor storybook illustration\n- Background: Pure white (#FFFFFF) - NO transparency\n- Output: Character from IMAGE A in pose from IMAGE B\n- Ensure only ONE pair of legs, ONE pair of arms, and ONE head per character\n\nGenerate the image now.`;\n\n  const requestBody = {\n    systemInstruction: {\n      role: 'system',\n      parts: [{ text: systemText }]\n    },\n    contents: [{\n      role: 'user',\n      parts: [\n        // APPEARANCE SOURCE FIRST (visual dominance)\n        { text: 'IMAGE A — CHARACTER REFERENCE (your source of truth for appearance):' },\n        { inlineData: { mimeType: \"image/png\", data: characterBase64 } },\n        // POSE SOURCE SECOND\n        { text: 'IMAGE B — POSE REFERENCE (body position ONLY, ignore character appearance):' },\n        { inlineData: { mimeType: \"image/png\", data: poseBase64 } },\n        // TASK LAST with explicit instructions\n        { text: promptText }\n      ]\n    }],\n    generationConfig: {\n      imageConfig: { aspectRatio: \"1:1\" },\n      temperature: 0.3  // Lower temperature for more consistency\n    }\n  };\n\n  results.push({\n    json: {\n      ...item.json,\n      requestBody: requestBody\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "f57f342c-b0c3-4998-9058-e16ede8b8aa5",
      "name": "Prepare Gemini Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2464,
        480
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "id": "e9f79a19-db8e-4ef7-8599-06a873c2bd05",
      "name": "Generate Character in Pose",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2272,
        480
      ],
      "credentials": {
        "openAiApi": {
          "id": "xhYw6tK9BPVC7BMo",
          "name": "OpenAi account 2"
        },
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract generated image from Gemini response - FINAL WORKING VERSION\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const currentPoseNumber = item.json.currentPoseNumber || (i + 1);\n  \n  try {\n    // The Gemini response is directly in the item.json\n    const responseData = item.json;\n    \n    if (!responseData.candidates || responseData.candidates.length === 0) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No candidates found in response',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    const candidate = responseData.candidates[0];\n    \n    // Check finish reason\n    if (candidate.finishReason && candidate.finishReason !== 'STOP') {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: `Generation not completed, finishReason: ${candidate.finishReason}`,\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    // Check for content and parts\n    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No content parts found in candidate',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    // Find the image part (it's in parts[1], not parts[0])\n    const imagePart = candidate.content.parts.find(part => part.inlineData && part.inlineData.data);\n    \n    if (!imagePart || !imagePart.inlineData || !imagePart.inlineData.data) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: 'No image data found in parts',\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    const imageData = imagePart.inlineData.data;\n    \n    if (!imageData || imageData.length < 100) {\n      results.push({\n        json: {\n          ...item.json,\n          extractedImageData: null,\n          extractionError: `Invalid image data (${imageData ? imageData.length : 'undefined'} chars)`,\n          _STATUS: 'FAILED'\n        }\n      });\n      continue;\n    }\n    \n    results.push({\n      json: {\n        ...item.json,\n        extractedImageData: imageData,\n        extractionSuccess: true,\n        _STATUS: 'IMAGE_FOUND'  // Changed to match your filter\n      }\n    });\n    \n  } catch (error) {\n    results.push({\n      json: {\n        ...item.json,\n        extractedImageData: null,\n        extractionError: error.message,\n        _STATUS: 'FAILED'\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "1bef1be6-8b0d-41dd-b544-2507c03aa7d1",
      "name": "Extract Generated Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2096,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Diagnostic: Check what fields we actually have\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  const diagnostic = {\n    itemIndex: i,\n    allKeys: Object.keys(item.json),\n    hasCharacterPath: !!item.json.characterPath,\n    hasCharacterHash: !!item.json.characterHash,\n    hasCurrentPoseNumber: !!item.json.currentPoseNumber,\n    hasCharacterSpecs: !!item.json.characterSpecs,\n    characterPath: item.json.characterPath,\n    characterHash: item.json.characterHash,\n    currentPoseNumber: item.json.currentPoseNumber\n  };\n  \n  results.push({\n    json: {\n      ...item.json,\n      _DIAGNOSTIC: diagnostic\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "f49ac275-ed59-4896-b4fb-4f89c4412784",
      "name": "DIAGNOSTIC: Check Fields",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1920,
        480
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json._STATUS }}",
              "value2": "IMAGE_FOUND"
            }
          ]
        }
      },
      "id": "0388dbdb-4195-48e5-8f27-49d66f6021d9",
      "name": "Filter: Only Items With Images",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1728,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge Remove.bg output with original metadata\n// The IF Filter node might not pass all data, so go back to Extract node\nconst removeBgItems = $input.all();\nconst extractItems = $('Extract Generated Image').all();\nconst results = [];\n\nfor (let i = 0; i < removeBgItems.length; i++) {\n  const removeBgItem = removeBgItems[i];\n  \n  // Find matching extract item by checking _STATUS field or other unique identifier\n  const matchingExtractItem = extractItems.find(ext => \n    ext.json._debug && ext.json._debug.poseNumber && \n    ext.json._debug.imageHash === removeBgItem.json.extractedImageData?.substring(0, 100)\n  ) || extractItems[i]; // Fallback to index\n  \n  if (!matchingExtractItem) {\n    throw new Error(`No matching extract item found for Remove.bg item ${i}. Total extract items: ${extractItems.length}`);\n  }\n  \n  // Debug: Check what fields we have\n  const debugInfo = {\n    hasCharacterPath: !!matchingExtractItem.json.characterPath,\n    hasPoseNumber: !!matchingExtractItem.json.currentPoseNumber,\n    hasCharacterHash: !!matchingExtractItem.json.characterHash,\n    extractItemKeys: Object.keys(matchingExtractItem.json),\n    itemIndex: i\n  };\n  \n  // Merge: metadata from extract + binary from remove.bg\n  results.push({\n    json: {\n      ...matchingExtractItem.json,\n      removeBgCompleted: true,\n      removeBgAt: new Date().toISOString(),\n      _mergeDebug: debugInfo\n    },\n    binary: removeBgItem.binary\n  });\n}\n\nreturn results;"
      },
      "id": "d5325b7a-f5ea-4e92-b62d-a2ad8f917070",
      "name": "Merge Remove.bg Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1216,
        304
      ],
      "disabled": true
    },
    {
      "parameters": {
        "functionCode": "// Basic quality validation (V1) - works with base64 data (no Remove.bg)\nconst items = $input.all();\nconst results = [];\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const poseNumber = item.json.currentPoseNumber || (i + 1);\n  \n  // Check for image data (base64 from Gemini, no background removal)\n  const hasImageData = !!item.json.extractedImageData;\n  const imageSize = hasImageData ? item.json.extractedImageData.length : 0;\n  \n  // Basic quality checks\n  const qualityChecks = {\n    hasImage: hasImageData,\n    hasTransparentBackground: false, // No Remove.bg, so no transparency\n    correctDimensions: true, // Assume Gemini generated correct size\n    fileSize: imageSize > 50000 // At least 50KB base64\n  };\n  \n  const qualityScore = Object.values(qualityChecks).filter(Boolean).length;\n  const isQualityAcceptable = qualityScore >= 2; // Lower threshold without bg removal\n  \n  // Convert base64 to binary for S3 upload\n  let binary = null;\n  if (hasImageData) {\n    const buffer = Buffer.from(item.json.extractedImageData, 'base64');\n    binary = await this.helpers.prepareBinaryData(buffer, `pose${poseNumber}.png`, 'image/png');\n  }\n  \n  results.push({\n    json: {\n      ...item.json,\n      qualityChecks,\n      qualityScore,\n      isQualityAcceptable,\n      overallValid: isQualityAcceptable,\n      validatedAt: new Date().toISOString(),\n      validationVersion: 'V1_BASIC_NO_BG_REMOVAL'\n    },\n    binary: binary ? { data: binary } : undefined\n  });\n}\n\nreturn results;"
      },
      "id": "a33fd270-a63a-4364-8fe5-8ba22f626c70",
      "name": "Validate Character Quality (V1 Basic)",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -960,
        480
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isQualityAcceptable }}",
              "value2": "={{ true }}"
            }
          ]
        }
      },
      "id": "b214ef53-b60a-4441-b026-87c22ca0994f",
      "name": "Check Quality Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -768,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare pose images for S3 upload - convert base64 to binary and set s3Path\nconst items = $input.all();\nconst results = [];\n\n// Get character hash from the Generate Character Hash node\nconst characterData = $('Generate Character Hash').first().json;\nconst characterHash = characterData.characterHash;\nconst characterPath = characterData.characterPath;\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  const poseNumber = item.json.currentPoseNumber || (i + 1);\n  \n  // Get the base64 image data from the validation step\n  const imageData = item.json.extractedImageData;\n  \n  if (!imageData || imageData.length < 100) {\n    throw new Error(`No valid image data found for pose ${poseNumber}`);\n  }\n  \n  // Convert base64 to binary for S3 upload\n  const buffer = Buffer.from(imageData, 'base64');\n  const binary = await this.helpers.prepareBinaryData(buffer, `pose${poseNumber}.png`, 'image/png');\n  \n  // Create S3 path using the character hash\n  const s3Path = `${characterPath}/characters_${characterHash}_pose${poseNumber.toString().padStart(2, '0')}.png`;\n  \n  console.log(`Preparing pose ${poseNumber} for S3 upload:`, {\n    s3Path: s3Path,\n    characterHash: characterHash,\n    bufferSize: buffer.length,\n    hasBinary: !!binary\n  });\n  \n  results.push({\n    json: {\n      ...item.json,\n      s3Path: s3Path,\n      poseNumber: poseNumber,\n      characterHash: characterHash,\n      readyForUpload: true\n    },\n    binary: { data: binary }\n  });\n}\n\nreturn results;"
      },
      "id": "bccfe6c8-31af-416b-a89c-23bf4193710f",
      "name": "Prepare for S3 Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -512,
        368
      ]
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.s3Path }}",
        "additionalFields": {}
      },
      "id": "67698d03-de02-4f1c-afc8-58afe5d2d100",
      "name": "Save Pose Character",
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -320,
        368
      ],
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Update pose generation progress - Process all saved poses\nconst s3Items = $input.all();\nconst prepareItems = $('Prepare for S3 Upload').all();\n\n// Get the order node to access base order data\nconst orderNode = $('Get Next Order from Queue').first();\nconst baseOrder = orderNode.json;\n\n// Count successful poses (items that made it through S3 upload)\nconst posesGenerated = s3Items.length;\nconst totalPoses = baseOrder.totalPosesRequired || 12;\nconst progress = Math.round((posesGenerated / totalPoses) * 100);\n\n// Get pose numbers from Prepare for S3 Upload (before S3 replaced the JSON)\nconst successfulPoseNumbers = prepareItems\n  .map((item, index) => item.json.currentPoseNumber || (index + 1))\n  .sort((a, b) => a - b);\n\n// Determine status based on success rate\nlet finalStatus;\nif (posesGenerated >= totalPoses) {\n  finalStatus = 'ai_generation_completed';\n} else if (posesGenerated > 0) {\n  finalStatus = 'ai_generation_partial'; // Some poses succeeded\n} else {\n  finalStatus = 'ai_generation_failed'; // No poses succeeded\n}\n\n// Create a single summary result (not one per pose)\nconst summary = {\n  ...baseOrder,\n  posesGenerated: posesGenerated,\n  posesRequired: totalPoses,\n  posesFailed: totalPoses - posesGenerated,\n  generationProgress: progress,\n  status: finalStatus,\n  aiGenerationCompletedAt: new Date().toISOString(),\n  successfulPoseNumbers: successfulPoseNumbers,\n  allPosesSuccessful: posesGenerated >= totalPoses\n};\n\nreturn [{ json: summary }];"
      },
      "id": "01555a31-37a9-4b65-b89f-a040c1c8c828",
      "name": "Update Pose Progress",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -128,
        368
      ]
    },
    {
      "parameters": {
        "functionCode": "// Retry pose generation with different parameters\nconst poseData = $input.first().json;\nconst orderData = $('Initialize Pose Generation Loop').first().json;\n\n// Increment retry count\nconst retryCount = orderData.poseGenerationAttempts + 1;\nconst maxRetries = orderData.maxPoseAttempts;\n\nif (retryCount >= maxRetries) {\n  // Max retries reached, mark as failed\n  const failedPose = {\n    ...orderData,\n    poseStatus: 'failed',\n    errorType: 'quality_validation_failed',\n    errorMessage: `Failed to generate quality pose after ${maxRetries} attempts`,\n    failedAt: new Date().toISOString()\n  };\n  \n  console.log(`Pose ${orderData.currentPoseNumber} failed after ${maxRetries} attempts`);\n  return [{ json: failedPose }];\n} else {\n  // Retry with modified prompt\n  const retryOrder = {\n    ...orderData,\n    poseGenerationAttempts: retryCount,\n    poseStatus: 'retrying',\n    retryAt: new Date().toISOString()\n  };\n  \n  console.log(`Retrying pose ${orderData.currentPoseNumber} (attempt ${retryCount}/${maxRetries})`);\n  return [{ json: retryOrder }];\n}"
      },
      "id": "ad04b461-238c-4f09-acd1-2d8ad0e9ed7a",
      "name": "Retry Pose Generation",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -384,
        592
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.allPosesSuccessful }}",
              "value2": true
            }
          ]
        }
      },
      "id": "1142975d-fbd1-466b-ac31-8b715be83907",
      "name": "Check All Poses Complete",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        144,
        368
      ]
    },
    {
      "parameters": {
        "functionCode": "// Process completion status and prepare for next step\nconst orderData = $input.first().json;\n\nlet result;\n\nif (orderData.status === 'ai_generation_completed') {\n  // All 5 poses generated successfully\n  result = {\n    ...orderData,\n    status: 'ready_for_book_assembly',\n    readyForAssemblyAt: new Date().toISOString(),\n    totalGenerationTime: orderData.aiGenerationStartedAt ? \n      (new Date(orderData.aiGenerationCompletedAt) - new Date(orderData.aiGenerationStartedAt)) : 0,\n    averageTimePerPose: orderData.aiGenerationStartedAt ?\n      Math.round((new Date(orderData.aiGenerationCompletedAt) - new Date(orderData.aiGenerationStartedAt)) / orderData.posesRequired / 1000) : 0\n  };\n} else if (orderData.status === 'ai_generation_partial') {\n  // Some poses succeeded, some failed\n  result = {\n    ...orderData,\n    status: 'ready_for_book_assembly_partial',\n    readyForAssemblyAt: new Date().toISOString(),\n    warning: `Only ${orderData.posesGenerated} of ${orderData.posesRequired} poses were successfully generated`\n  };\n} else {\n  // Failed completely\n  result = {\n    ...orderData,\n    status: 'ai_generation_failed_completely',\n    failedAt: new Date().toISOString()\n  };\n}\n\nreturn [{ json: result }];"
      },
      "id": "d8e0ba3d-2f3d-4044-980d-ba51e8c4f49a",
      "name": "Process Completion Status",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        416,
        352
      ]
    },
    {
      "parameters": {
        "functionCode": "// Log generation results for monitoring\nconst orderData = $input.first().json;\n\nconst logEntry = {\n  timestamp: new Date().toISOString(),\n  workflow: '2-ai-character-generation',\n  orderId: orderData.amazonOrderId || 'N/A',\n  status: orderData.status,\n  posesGenerated: orderData.posesGenerated,\n  posesRequired: orderData.posesRequired || orderData.totalPosesRequired,\n  posesFailed: orderData.posesFailed || 0,\n  generationProgress: orderData.generationProgress,\n  successfulPoseNumbers: orderData.successfulPoseNumbers || [],\n  allPosesSuccessful: orderData.allPosesSuccessful || false,\n  warning: orderData.warning || null,\n  generationTime: orderData.totalGenerationTime || 'N/A',\n  averageTimePerPose: orderData.averageTimePerPose || 'N/A'\n};\n\n// In production, this would write to a proper logging system\nconsole.log('AI Generation Results:', JSON.stringify(logEntry, null, 2));\n\nreturn [{ json: logEntry }];"
      },
      "id": "3d704f79-7047-4cb4-b884-16ebba1c1521",
      "name": "Log Generation Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        640,
        352
      ]
    },
    {
      "parameters": {
        "url": "https://pub-92cec53654f84771956bc84dfea65baa.r2.dev/book-mvp-simple-adventure/characters/base-character.png",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4400,
        464
      ],
      "id": "1cc5b616-6ecd-4830-b3a4-c68c69e67b32",
      "name": "Load Reference Image"
    },
    {
      "parameters": {
        "jsCode": "// Generate a mock order for testing the AI character generation workflow\n// This simulates an order coming from the order intake workflow\n\nconst mockOrder = {\n  amazonOrderId: 'TEST-ORDER-001',\n  status: 'queued_for_processing',\n  orderDate: new Date().toISOString(),\n  customerEmail: 'test@example.com',\n  characterSpecs: {\n    childName: 'Alex',\n    skinTone: 'medium african-american',\n    hairColor: 'black',\n    hairStyle: 'pom pom',\n    age: 4,\n    pronouns: 'they/them',\n    favoriteColor: 'green',\n    animalGuide: 'unicorn',\n    clothingStyle: 't-shirt and shorts'\n  },\n  bookSpecs: {\n    title: 'Alex and the Adventure Compass',\n    totalPages: 16,\n    format: '8.5x8.5_softcover',\n    bookType: 'animal-guide' // or 'mvp-simple' for different book types\n  },\n  orderDetails: {\n    quantity: 1,\n    shippingAddress: {\n      name: 'Test Customer',\n      address: '123 Test Street',\n      city: 'Test City',\n      state: 'CA',\n      zip: '90210'\n    }\n  }\n};\n\nconsole.log('Generated mock order for testing:', mockOrder);\nreturn [{ json: mockOrder }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5056,
        256
      ],
      "id": "962616d0-c064-4bd7-add5-115a192ed8d2",
      "name": "Generate Mock Order"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -5296,
        208
      ],
      "id": "3767be79-18fc-4019-a81b-32348798faed",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googlePalmApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.requestBody }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -4048,
        464
      ],
      "id": "ab0ab1a6-efbb-420d-81ed-7184af1e7de0",
      "name": "Generate Custom Base Character",
      "credentials": {
        "openAiApi": {
          "id": "xhYw6tK9BPVC7BMo",
          "name": "OpenAi account 2"
        },
        "googlePalmApi": {
          "id": "7jdcfc9T2O9vensv",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Robustly extract first image from Gemini response and output as n8n binary\nconst input = $input.first();\nconst res = input.json; // This is the Gemini response\n\n// Find the first part that has inlineData.data\nconst parts = res?.candidates?.[0]?.content?.parts ?? [];\nconst imagePart =\n  parts.find(p => p?.inlineData?.data) ||\n  (Array.isArray(parts[0]?.parts) ? parts[0].parts.find(p => p?.inlineData?.data) : null);\n\nif (!imagePart?.inlineData?.data) {\n  throw new Error('No inlineData image found in Gemini response. Parts seen: ' +\n    JSON.stringify(parts.map(p => Object.keys(p))));\n}\n\nconst mime = imagePart.inlineData.mimeType || 'image/png';\nconst buf = Buffer.from(imagePart.inlineData.data, 'base64');\n\n// Prepare n8n binary (works in filesystem mode)\nconst binary = await this.helpers.prepareBinaryData(buf, 'generated.png', mime);\n\n// Get the original order data from \"Generate Character Hash\" which has characterPath and characterHash\nconst originalOrderData = $('Generate Character Hash').first().json;\n\nreturn [{\n  json: {\n    ...originalOrderData, // Pass through all original order data including characterPath and characterHash!\n    generatedImage: { mimeType: mime, size: buf.length }\n  },\n  binary: { data: binary }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3856,
        464
      ],
      "id": "555cbb59-8cb1-4e46-be5e-e6eaaec469d9",
      "name": "Process Gemini API response and extract generated image"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first();\nconst binaryKey = 'data'; // exact key from the Binary tab\n\n// this resolves the file from filesystem-v2 and returns a Buffer\nconst buffer = await this.helpers.getBinaryDataBuffer(0, binaryKey);\nconst base64Image = buffer.toString('base64');\n\nif (!base64Image || base64Image.length < 100) {\n  throw new Error('Invalid base64 from binary buffer');\n}\n\nconst cs = item.json.characterSpecs;\nconst requestBody = {\n  contents: [{\n    parts: [\n      { text: `Use this reference image as a style guide. Recreate this exact character pose with the following changes: skin tone: ${cs.skinTone}, hair color: ${cs.hairColor}, hair style: ${cs.hairStyle}, clothing style: ${cs.clothingStyle}, favorite color: ${cs.favoriteColor}. Maintain the same watercolor storybook style, proportions, and pose. Character should be on pure white background (#FFFFFF) - NO transparency. Age-appropriate for ${cs.age} years old.` },\n      { inlineData: { mimeType: \"image/png\", data: base64Image } }\n    ]\n  }],\n  generationConfig: { imageConfig: { aspectRatio: \"1:1\" } }\n};\n\nreturn [{ json: { ...item.json, requestBody } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4224,
        464
      ],
      "id": "4962ad1b-b55c-4ac3-bd97-684c0cf219c2",
      "name": "Prepare binary"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "little-hero-assets",
        "fileName": "=book-mvp-simple-adventure/order-generated-assets/{{ $json.characterPath }}/base-character.png",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.s3",
      "typeVersion": 1,
      "position": [
        -3712,
        464
      ],
      "id": "aa786ce2-1d5a-4e58-b284-833eb896e0ac",
      "name": "Upload a file",
      "credentials": {
        "s3": {
          "id": "7tJOX9QjL1jqyEjf",
          "name": "S3 account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.remove.bg/v1.0/removebg",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Api-Key",
              "value": "8F3yGjK52ktfRb9KHucMgHCA"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"image_file_b64\": $json.extractedImageData,\n  \"size\": \"auto\",\n  \"format\": \"png\"\n} }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "id": "ca1cb75e-c526-4ee3-b580-168429084c63",
      "name": "Remove Background (Pose)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1440,
        304
      ],
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "Generate Character in Pose": {
      "main": [
        [
          {
            "node": "Extract Generated Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Generated Image": {
      "main": [
        [
          {
            "node": "DIAGNOSTIC: Check Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DIAGNOSTIC: Check Fields": {
      "main": [
        [
          {
            "node": "Filter: Only Items With Images",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter: Only Items With Images": {
      "main": [
        [
          {
            "node": "Remove Background (Pose)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Character Quality (V1 Basic)": {
      "main": [
        [
          {
            "node": "Check Quality Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Quality Validation": {
      "main": [
        [
          {
            "node": "Prepare for S3 Upload",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Retry Pose Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for S3 Upload": {
      "main": [
        [
          {
            "node": "Save Pose Character",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Pose Character": {
      "main": [
        [
          {
            "node": "Update Pose Progress",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Pose Progress": {
      "main": [
        [
          {
            "node": "Check All Poses Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check All Poses Complete": {
      "main": [
        [
          {
            "node": "Process Completion Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Completion Status": {
      "main": [
        [
          {
            "node": "Log Generation Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Next Order from Queue": {
      "main": [
        [
          {
            "node": "Generate Character Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Character Hash": {
      "main": [
        [
          {
            "node": "Load Reference Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Reference Image": {
      "main": [
        [
          {
            "node": "Prepare binary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Mock Order": {
      "main": [
        [
          {
            "node": "Get Next Order from Queue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Generate Mock Order",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Custom Base Character": {
      "main": [
        [
          {
            "node": "Process Gemini API response and extract generated image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare binary": {
      "main": [
        [
          {
            "node": "Generate Custom Base Character",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Gemini API response and extract generated image": {
      "main": [
        [
          {
            "node": "Upload a file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload a file": {
      "main": [
        [
          {
            "node": "Restore Metadata After Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Metadata After Upload": {
      "main": [
        [
          {
            "node": "Load Custom Character from R2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Custom Character from R2": {
      "main": [
        [
          {
            "node": "Initialize Pose Generation Loop",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Pose Generation Loop": {
      "main": [
        [
          {
            "node": "Load Pose Reference",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Pose Reference": {
      "main": [
        [
          {
            "node": "Merge Character with Poses",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Character with Poses": {
      "main": [
        [
          {
            "node": "Reorganize Merged Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reorganize Merged Data": {
      "main": [
        [
          {
            "node": "Prepare Gemini Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gemini Requests": {
      "main": [
        [
          {
            "node": "Generate Character in Pose",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Remove.bg Output": {
      "main": [
        [
          {
            "node": "Validate Character Quality (V1 Basic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Background (Pose)": {
      "main": [
        [
          {
            "node": "Merge Remove.bg Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a16db9f8-8fb9-4ac6-9faa-e866a34cb313",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "010748b7a1466c46dced3f8b2bdbc3bc174722f0672e5a4c9529354f5ff306f8"
  },
  "id": "jZaJkKT9LRF6SfDC",
  "tags": []
}